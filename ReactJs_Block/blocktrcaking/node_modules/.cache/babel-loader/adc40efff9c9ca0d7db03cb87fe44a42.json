{"ast":null,"code":"/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Extends an object's prototype by another's.\r\n *\r\n * @param type1 The Type to be extended.\r\n * @param type2 The Type to extend with.\r\n * @ignore\r\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1, type2) {\n  // eslint-disable-next-line prefer-const\n  for (let property in type2.prototype) {\n    type1.prototype[property] = type2.prototype[property];\n  }\n}\n/**\r\n * @ignore\r\n */\n\n\nclass OverlayViewSafe {\n  constructor() {\n    // MarkerClusterer implements google.maps.OverlayView interface. We use the\n    // extend function to extend MarkerClusterer with google.maps.OverlayView\n    // because it might not always be available when the code is defined so we\n    // look for it at the last possible moment. If it doesn't exist now then\n    // there is no point going ahead :)\n    extend(OverlayViewSafe, google.maps.OverlayView);\n  }\n\n}\n/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n *\r\n * @hidden\r\n */\n\n\nfunction toCssText(styles) {\n  return Object.keys(styles).reduce((acc, key) => {\n    if (styles[key]) {\n      acc.push(key + \":\" + styles[key]);\n    }\n\n    return acc;\n  }, []).join(\";\");\n}\n/**\r\n *\r\n * @hidden\r\n */\n\n\nfunction coercePixels(pixels) {\n  return pixels ? pixels + \"px\" : undefined;\n}\n/**\r\n * A cluster icon.\r\n */\n\n\nclass ClusterIcon extends OverlayViewSafe {\n  /**\r\n   * @param cluster_ The cluster with which the icon is to be associated.\r\n   * @param styles_ An array of {@link ClusterIconStyle} defining the cluster icons\r\n   *  to use for various cluster sizes.\r\n   */\n  constructor(cluster_, styles_) {\n    super();\n    this.cluster_ = cluster_;\n    this.styles_ = styles_;\n    this.center_ = null;\n    this.div_ = null;\n    this.sums_ = null;\n    this.visible_ = false;\n    this.style = null;\n    this.setMap(cluster_.getMap()); // Note: this causes onAdd to be called\n  }\n  /**\r\n   * Adds the icon to the DOM.\r\n   */\n\n\n  onAdd() {\n    let cMouseDownInCluster;\n    let cDraggingMapByCluster;\n    const mc = this.cluster_.getMarkerClusterer();\n    const [major, minor] = google.maps.version.split(\".\");\n    const gmVersion = parseInt(major, 10) * 100 + parseInt(minor, 10);\n    this.div_ = document.createElement(\"div\");\n\n    if (this.visible_) {\n      this.show();\n    }\n\n    this.getPanes().overlayMouseTarget.appendChild(this.div_); // Fix for Issue 157\n\n    this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), \"bounds_changed\", function () {\n      cDraggingMapByCluster = cMouseDownInCluster;\n    });\n    google.maps.event.addDomListener(this.div_, \"mousedown\", () => {\n      cMouseDownInCluster = true;\n      cDraggingMapByCluster = false;\n    }); // March 1, 2018: Fix for this 3.32 exp bug, https://issuetracker.google.com/issues/73571522\n    // But it doesn't work with earlier releases so do a version check.\n\n    if (gmVersion >= 332) {\n      // Ugly version-dependent code\n      google.maps.event.addDomListener(this.div_, \"touchstart\", e => {\n        e.stopPropagation();\n      });\n    }\n\n    google.maps.event.addDomListener(this.div_, \"click\", e => {\n      cMouseDownInCluster = false;\n\n      if (!cDraggingMapByCluster) {\n        /**\r\n         * This event is fired when a cluster marker is clicked.\r\n         * @name MarkerClusterer#click\r\n         * @param {Cluster} c The cluster that was clicked.\r\n         * @event\r\n         */\n        google.maps.event.trigger(mc, \"click\", this.cluster_);\n        google.maps.event.trigger(mc, \"clusterclick\", this.cluster_); // deprecated name\n        // The default click handler follows. Disable it by setting\n        // the zoomOnClick property to false.\n\n        if (mc.getZoomOnClick()) {\n          // Zoom into the cluster.\n          const mz = mc.getMaxZoom();\n          const theBounds = this.cluster_.getBounds();\n          mc.getMap().fitBounds(theBounds); // There is a fix for Issue 170 here:\n\n          setTimeout(function () {\n            mc.getMap().fitBounds(theBounds); // Don't zoom beyond the max zoom level\n\n            if (mz !== null && mc.getMap().getZoom() > mz) {\n              mc.getMap().setZoom(mz + 1);\n            }\n          }, 100);\n        } // Prevent event propagation to the map:\n\n\n        e.cancelBubble = true;\n\n        if (e.stopPropagation) {\n          e.stopPropagation();\n        }\n      }\n    });\n    google.maps.event.addDomListener(this.div_, \"mouseover\", () => {\n      /**\r\n       * This event is fired when the mouse moves over a cluster marker.\r\n       * @name MarkerClusterer#mouseover\r\n       * @param {Cluster} c The cluster that the mouse moved over.\r\n       * @event\r\n       */\n      google.maps.event.trigger(mc, \"mouseover\", this.cluster_);\n    });\n    google.maps.event.addDomListener(this.div_, \"mouseout\", () => {\n      /**\r\n       * This event is fired when the mouse moves out of a cluster marker.\r\n       * @name MarkerClusterer#mouseout\r\n       * @param {Cluster} c The cluster that the mouse moved out of.\r\n       * @event\r\n       */\n      google.maps.event.trigger(mc, \"mouseout\", this.cluster_);\n    });\n  }\n  /**\r\n   * Removes the icon from the DOM.\r\n   */\n\n\n  onRemove() {\n    if (this.div_ && this.div_.parentNode) {\n      this.hide();\n      google.maps.event.removeListener(this.boundsChangedListener_);\n      google.maps.event.clearInstanceListeners(this.div_);\n      this.div_.parentNode.removeChild(this.div_);\n      this.div_ = null;\n    }\n  }\n  /**\r\n   * Draws the icon.\r\n   */\n\n\n  draw() {\n    if (this.visible_) {\n      const pos = this.getPosFromLatLng_(this.center_);\n      this.div_.style.top = pos.y + \"px\";\n      this.div_.style.left = pos.x + \"px\";\n    }\n  }\n  /**\r\n   * Hides the icon.\r\n   */\n\n\n  hide() {\n    if (this.div_) {\n      this.div_.style.display = \"none\";\n    }\n\n    this.visible_ = false;\n  }\n  /**\r\n   * Positions and shows the icon.\r\n   */\n\n\n  show() {\n    if (this.div_) {\n      this.div_.className = this.className_;\n      this.div_.style.cssText = this.createCss_(this.getPosFromLatLng_(this.center_));\n      this.div_.innerHTML = (this.style.url ? this.getImageElementHtml() : \"\") + this.getLabelDivHtml();\n\n      if (typeof this.sums_.title === \"undefined\" || this.sums_.title === \"\") {\n        this.div_.title = this.cluster_.getMarkerClusterer().getTitle();\n      } else {\n        this.div_.title = this.sums_.title;\n      }\n\n      this.div_.style.display = \"\";\n    }\n\n    this.visible_ = true;\n  }\n\n  getLabelDivHtml() {\n    const mc = this.cluster_.getMarkerClusterer();\n    const ariaLabel = mc.ariaLabelFn(this.sums_.text);\n    const divStyle = {\n      position: \"absolute\",\n      top: coercePixels(this.anchorText_[0]),\n      left: coercePixels(this.anchorText_[1]),\n      color: this.style.textColor,\n      \"font-size\": coercePixels(this.style.textSize),\n      \"font-family\": this.style.fontFamily,\n      \"font-weight\": this.style.fontWeight,\n      \"font-style\": this.style.fontStyle,\n      \"text-decoration\": this.style.textDecoration,\n      \"text-align\": \"center\",\n      width: coercePixels(this.style.width),\n      \"line-height\": coercePixels(this.style.textLineHeight)\n    };\n    return `\n<div aria-label=\"${ariaLabel}\" style=\"${toCssText(divStyle)}\" tabindex=\"0\">\n  <span aria-hidden=\"true\">${this.sums_.text}</span>\n</div>\n`;\n  }\n\n  getImageElementHtml() {\n    // NOTE: values must be specified in px units\n    const bp = (this.style.backgroundPosition || \"0 0\").split(\" \");\n    const spriteH = parseInt(bp[0].replace(/^\\s+|\\s+$/g, \"\"), 10);\n    const spriteV = parseInt(bp[1].replace(/^\\s+|\\s+$/g, \"\"), 10);\n    let dimensions = {};\n\n    if (this.cluster_.getMarkerClusterer().getEnableRetinaIcons()) {\n      dimensions = {\n        width: coercePixels(this.style.width),\n        height: coercePixels(this.style.height)\n      };\n    } else {\n      const [Y1, X1, Y2, X2] = [-1 * spriteV, -1 * spriteH + this.style.width, -1 * spriteV + this.style.height, -1 * spriteH];\n      dimensions = {\n        clip: `rect(${Y1}px, ${X1}px, ${Y2}px, ${X2}px)`\n      };\n    }\n\n    const cssText = toCssText(Object.assign({\n      position: \"absolute\",\n      top: coercePixels(spriteV),\n      left: coercePixels(spriteH)\n    }, dimensions));\n    return `<img alt=\"${this.sums_.text}\" aria-hidden=\"true\" src=\"${this.style.url}\" style=\"${cssText}\"/>`;\n  }\n  /**\r\n   * Sets the icon styles to the appropriate element in the styles array.\r\n   *\r\n   * @ignore\r\n   * @param sums The icon label text and styles index.\r\n   */\n\n\n  useStyle(sums) {\n    this.sums_ = sums;\n    let index = Math.max(0, sums.index - 1);\n    index = Math.min(this.styles_.length - 1, index);\n    this.style = this.styles_[index];\n    this.anchorText_ = this.style.anchorText || [0, 0];\n    this.anchorIcon_ = this.style.anchorIcon || [Math.floor(this.style.height / 2), Math.floor(this.style.width / 2)];\n    this.className_ = this.cluster_.getMarkerClusterer().getClusterClass() + \" \" + (this.style.className || \"cluster-\" + index);\n  }\n  /**\r\n   * Sets the position at which to center the icon.\r\n   *\r\n   * @param center The latlng to set as the center.\r\n   */\n\n\n  setCenter(center) {\n    this.center_ = center;\n  }\n  /**\r\n   * Creates the `cssText` style parameter based on the position of the icon.\r\n   *\r\n   * @param pos The position of the icon.\r\n   * @return The CSS style text.\r\n   */\n\n\n  createCss_(pos) {\n    return toCssText({\n      \"z-index\": `${this.cluster_.getMarkerClusterer().getZIndex()}`,\n      top: coercePixels(pos.y),\n      left: coercePixels(pos.x),\n      width: coercePixels(this.style.width),\n      height: coercePixels(this.style.height),\n      cursor: \"pointer\",\n      position: \"absolute\",\n      \"-webkit-user-select\": \"none\",\n      \"-khtml-user-select\": \"none\",\n      \"-moz-user-select\": \"none\",\n      \"-o-user-select\": \"none\",\n      \"user-select\": \"none\"\n    });\n  }\n  /**\r\n   * Returns the position at which to place the DIV depending on the latlng.\r\n   *\r\n   * @param latlng The position in latlng.\r\n   * @return The position in pixels.\r\n   */\n\n\n  getPosFromLatLng_(latlng) {\n    const pos = this.getProjection().fromLatLngToDivPixel(latlng);\n    pos.x = Math.floor(pos.x - this.anchorIcon_[1]);\n    pos.y = Math.floor(pos.y - this.anchorIcon_[0]);\n    return pos;\n  }\n\n}\n/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Creates a single cluster that manages a group of proximate markers.\r\n *  Used internally, do not call this constructor directly.\r\n */\n\n\nclass Cluster {\n  /**\r\n   *\r\n   * @param markerClusterer_ The `MarkerClusterer` object with which this\r\n   *  cluster is associated.\r\n   */\n  constructor(markerClusterer_) {\n    this.markerClusterer_ = markerClusterer_;\n    this.map_ = this.markerClusterer_.getMap();\n    this.minClusterSize_ = this.markerClusterer_.getMinimumClusterSize();\n    this.averageCenter_ = this.markerClusterer_.getAverageCenter();\n    this.markers_ = []; // TODO: type;\n\n    this.center_ = null;\n    this.bounds_ = null;\n    this.clusterIcon_ = new ClusterIcon(this, this.markerClusterer_.getStyles());\n  }\n  /**\r\n   * Returns the number of markers managed by the cluster. You can call this from\r\n   * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\r\n   *\r\n   * @return The number of markers in the cluster.\r\n   */\n\n\n  getSize() {\n    return this.markers_.length;\n  }\n  /**\r\n   * Returns the array of markers managed by the cluster. You can call this from\r\n   * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\r\n   *\r\n   * @return The array of markers in the cluster.\r\n   */\n\n\n  getMarkers() {\n    return this.markers_;\n  }\n  /**\r\n   * Returns the center of the cluster. You can call this from\r\n   * a `click`, `mouseover`, or `mouseout` event handler\r\n   * for the `MarkerClusterer` object.\r\n   *\r\n   * @return The center of the cluster.\r\n   */\n\n\n  getCenter() {\n    return this.center_;\n  }\n  /**\r\n   * Returns the map with which the cluster is associated.\r\n   *\r\n   * @return The map.\r\n   * @ignore\r\n   */\n\n\n  getMap() {\n    return this.map_;\n  }\n  /**\r\n   * Returns the `MarkerClusterer` object with which the cluster is associated.\r\n   *\r\n   * @return The associated marker clusterer.\r\n   * @ignore\r\n   */\n\n\n  getMarkerClusterer() {\n    return this.markerClusterer_;\n  }\n  /**\r\n   * Returns the bounds of the cluster.\r\n   *\r\n   * @return the cluster bounds.\r\n   * @ignore\r\n   */\n\n\n  getBounds() {\n    const bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n    const markers = this.getMarkers();\n\n    for (let i = 0; i < markers.length; i++) {\n      bounds.extend(markers[i].getPosition());\n    }\n\n    return bounds;\n  }\n  /**\r\n   * Removes the cluster from the map.\r\n   *\r\n   * @ignore\r\n   */\n\n\n  remove() {\n    this.clusterIcon_.setMap(null);\n    this.markers_ = [];\n    delete this.markers_;\n  }\n  /**\r\n   * Adds a marker to the cluster.\r\n   *\r\n   * @param marker The marker to be added.\r\n   * @return True if the marker was added.\r\n   * @ignore\r\n   */\n\n\n  addMarker(marker) {\n    if (this.isMarkerAlreadyAdded_(marker)) {\n      return false;\n    }\n\n    if (!this.center_) {\n      this.center_ = marker.getPosition();\n      this.calculateBounds_();\n    } else {\n      if (this.averageCenter_) {\n        const l = this.markers_.length + 1;\n        const lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;\n        const lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;\n        this.center_ = new google.maps.LatLng(lat, lng);\n        this.calculateBounds_();\n      }\n    }\n\n    marker.isAdded = true;\n    this.markers_.push(marker);\n    const mCount = this.markers_.length;\n    const mz = this.markerClusterer_.getMaxZoom();\n\n    if (mz !== null && this.map_.getZoom() > mz) {\n      // Zoomed in past max zoom, so show the marker.\n      if (marker.getMap() !== this.map_) {\n        marker.setMap(this.map_);\n      }\n    } else if (mCount < this.minClusterSize_) {\n      // Min cluster size not reached so show the marker.\n      if (marker.getMap() !== this.map_) {\n        marker.setMap(this.map_);\n      }\n    } else if (mCount === this.minClusterSize_) {\n      // Hide the markers that were showing.\n      for (let i = 0; i < mCount; i++) {\n        this.markers_[i].setMap(null);\n      }\n    } else {\n      marker.setMap(null);\n    }\n\n    return true;\n  }\n  /**\r\n   * Determines if a marker lies within the cluster's bounds.\r\n   *\r\n   * @param marker The marker to check.\r\n   * @return True if the marker lies in the bounds.\r\n   * @ignore\r\n   */\n\n\n  isMarkerInClusterBounds(marker) {\n    return this.bounds_.contains(marker.getPosition());\n  }\n  /**\r\n   * Calculates the extended bounds of the cluster with the grid.\r\n   */\n\n\n  calculateBounds_() {\n    const bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n    this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n  }\n  /**\r\n   * Updates the cluster icon.\r\n   */\n\n\n  updateIcon() {\n    const mCount = this.markers_.length;\n    const mz = this.markerClusterer_.getMaxZoom();\n\n    if (mz !== null && this.map_.getZoom() > mz) {\n      this.clusterIcon_.hide();\n      return;\n    }\n\n    if (mCount < this.minClusterSize_) {\n      // Min cluster size not yet reached.\n      this.clusterIcon_.hide();\n      return;\n    }\n\n    const numStyles = this.markerClusterer_.getStyles().length;\n    const sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n    this.clusterIcon_.setCenter(this.center_);\n    this.clusterIcon_.useStyle(sums);\n    this.clusterIcon_.show();\n  }\n  /**\r\n   * Determines if a marker has already been added to the cluster.\r\n   *\r\n   * @param marker The marker to check.\r\n   * @return True if the marker has already been added.\r\n   */\n\n\n  isMarkerAlreadyAdded_(marker) {\n    if (this.markers_.indexOf) {\n      return this.markers_.indexOf(marker) !== -1;\n    } else {\n      for (let i = 0; i < this.markers_.length; i++) {\n        if (marker === this.markers_[i]) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n}\n/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * @ignore\r\n */\n\n\nconst getOption = (options, prop, def) => {\n  if (options[prop] !== undefined) {\n    return options[prop];\n  } else {\n    return def;\n  }\n};\n\nclass MarkerClusterer extends OverlayViewSafe {\n  /**\r\n   * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.\r\n   * @param map The Google map to attach to.\r\n   * @param markers The markers to be added to the cluster.\r\n   * @param options The optional parameters.\r\n   */\n  constructor(map) {\n    let markers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.options = options;\n    this.markers_ = [];\n    this.clusters_ = [];\n    this.listeners_ = [];\n    this.activeMap_ = null;\n    this.ready_ = false;\n\n    this.ariaLabelFn = this.options.ariaLabelFn || (() => \"\");\n\n    this.zIndex_ = this.options.zIndex || google.maps.Marker.MAX_ZINDEX + 1;\n    this.gridSize_ = this.options.gridSize || 60;\n    this.minClusterSize_ = this.options.minimumClusterSize || 2;\n    this.maxZoom_ = this.options.maxZoom || null;\n    this.styles_ = this.options.styles || [];\n    this.title_ = this.options.title || \"\";\n    this.zoomOnClick_ = getOption(this.options, \"zoomOnClick\", true);\n    this.averageCenter_ = getOption(this.options, \"averageCenter\", false);\n    this.ignoreHidden_ = getOption(this.options, \"ignoreHidden\", false);\n    this.enableRetinaIcons_ = getOption(this.options, \"enableRetinaIcons\", false);\n    this.imagePath_ = this.options.imagePath || MarkerClusterer.IMAGE_PATH;\n    this.imageExtension_ = this.options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;\n    this.imageSizes_ = this.options.imageSizes || MarkerClusterer.IMAGE_SIZES;\n    this.calculator_ = this.options.calculator || MarkerClusterer.CALCULATOR;\n    this.batchSize_ = this.options.batchSize || MarkerClusterer.BATCH_SIZE;\n    this.batchSizeIE_ = this.options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;\n    this.clusterClass_ = this.options.clusterClass || \"cluster\";\n\n    if (navigator.userAgent.toLowerCase().indexOf(\"msie\") !== -1) {\n      // Try to avoid IE timeout when processing a huge number of markers:\n      this.batchSize_ = this.batchSizeIE_;\n    }\n\n    this.setupStyles_();\n    this.addMarkers(markers, true);\n    this.setMap(map); // Note: this causes onAdd to be called\n  }\n  /**\r\n   * Implementation of the onAdd interface method.\r\n   * @ignore\r\n   */\n\n\n  onAdd() {\n    this.activeMap_ = this.getMap();\n    this.ready_ = true;\n    this.repaint();\n    this.prevZoom_ = this.getMap().getZoom(); // Add the map event listeners\n\n    this.listeners_ = [google.maps.event.addListener(this.getMap(), \"zoom_changed\", () => {\n      const map = this.getMap(); // eslint-disable-line @typescript-eslint/no-explicit-any\n      // Fix for bug #407\n      // Determines map type and prevents illegal zoom levels\n\n      const minZoom = map.minZoom || 0;\n      const maxZoom = Math.min(map.maxZoom || 100, map.mapTypes[map.getMapTypeId()].maxZoom);\n      const zoom = Math.min(Math.max(this.getMap().getZoom(), minZoom), maxZoom);\n\n      if (this.prevZoom_ != zoom) {\n        this.prevZoom_ = zoom;\n        this.resetViewport_(false);\n      }\n    }), google.maps.event.addListener(this.getMap(), \"idle\", () => {\n      this.redraw_();\n    })];\n  }\n  /**\r\n   * Implementation of the onRemove interface method.\r\n   * Removes map event listeners and all cluster icons from the DOM.\r\n   * All managed markers are also put back on the map.\r\n   * @ignore\r\n   */\n\n\n  onRemove() {\n    // Put all the managed markers back on the map:\n    for (let i = 0; i < this.markers_.length; i++) {\n      if (this.markers_[i].getMap() !== this.activeMap_) {\n        this.markers_[i].setMap(this.activeMap_);\n      }\n    } // Remove all clusters:\n\n\n    for (let i = 0; i < this.clusters_.length; i++) {\n      this.clusters_[i].remove();\n    }\n\n    this.clusters_ = []; // Remove map event listeners:\n\n    for (let i = 0; i < this.listeners_.length; i++) {\n      google.maps.event.removeListener(this.listeners_[i]);\n    }\n\n    this.listeners_ = [];\n    this.activeMap_ = null;\n    this.ready_ = false;\n  }\n  /**\r\n   * Implementation of the draw interface method.\r\n   * @ignore\r\n   */\n\n\n  draw() {}\n  /**\r\n   * Sets up the styles object.\r\n   */\n\n\n  setupStyles_() {\n    if (this.styles_.length > 0) {\n      return;\n    }\n\n    for (let i = 0; i < this.imageSizes_.length; i++) {\n      const size = this.imageSizes_[i];\n      this.styles_.push(MarkerClusterer.withDefaultStyle({\n        url: this.imagePath_ + (i + 1) + \".\" + this.imageExtension_,\n        height: size,\n        width: size\n      }));\n    }\n  }\n  /**\r\n   *  Fits the map to the bounds of the markers managed by the clusterer.\r\n   */\n\n\n  fitMapToMarkers(padding) {\n    const markers = this.getMarkers();\n    const bounds = new google.maps.LatLngBounds();\n\n    for (let i = 0; i < markers.length; i++) {\n      // March 3, 2018: Bug fix -- honor the ignoreHidden property\n      if (markers[i].getVisible() || !this.getIgnoreHidden()) {\n        bounds.extend(markers[i].getPosition());\n      }\n    }\n\n    this.getMap().fitBounds(bounds, padding);\n  }\n  /**\r\n   * Returns the value of the `gridSize` property.\r\n   *\r\n   * @return The grid size.\r\n   */\n\n\n  getGridSize() {\n    return this.gridSize_;\n  }\n  /**\r\n   * Sets the value of the `gridSize` property.\r\n   *\r\n   * @param gridSize The grid size.\r\n   */\n\n\n  setGridSize(gridSize) {\n    this.gridSize_ = gridSize;\n  }\n  /**\r\n   * Returns the value of the `minimumClusterSize` property.\r\n   *\r\n   * @return The minimum cluster size.\r\n   */\n\n\n  getMinimumClusterSize() {\n    return this.minClusterSize_;\n  }\n  /**\r\n   * Sets the value of the `minimumClusterSize` property.\r\n   *\r\n   * @param minimumClusterSize The minimum cluster size.\r\n   */\n\n\n  setMinimumClusterSize(minimumClusterSize) {\n    this.minClusterSize_ = minimumClusterSize;\n  }\n  /**\r\n   *  Returns the value of the `maxZoom` property.\r\n   *\r\n   *  @return The maximum zoom level.\r\n   */\n\n\n  getMaxZoom() {\n    return this.maxZoom_;\n  }\n  /**\r\n   *  Sets the value of the `maxZoom` property.\r\n   *\r\n   *  @param maxZoom The maximum zoom level.\r\n   */\n\n\n  setMaxZoom(maxZoom) {\n    this.maxZoom_ = maxZoom;\n  }\n\n  getZIndex() {\n    return this.zIndex_;\n  }\n\n  setZIndex(zIndex) {\n    this.zIndex_ = zIndex;\n  }\n  /**\r\n   *  Returns the value of the `styles` property.\r\n   *\r\n   *  @return The array of styles defining the cluster markers to be used.\r\n   */\n\n\n  getStyles() {\n    return this.styles_;\n  }\n  /**\r\n   *  Sets the value of the `styles` property.\r\n   *\r\n   *  @param styles The array of styles to use.\r\n   */\n\n\n  setStyles(styles) {\n    this.styles_ = styles;\n  }\n  /**\r\n   * Returns the value of the `title` property.\r\n   *\r\n   * @return The content of the title text.\r\n   */\n\n\n  getTitle() {\n    return this.title_;\n  }\n  /**\r\n   *  Sets the value of the `title` property.\r\n   *\r\n   *  @param title The value of the title property.\r\n   */\n\n\n  setTitle(title) {\n    this.title_ = title;\n  }\n  /**\r\n   * Returns the value of the `zoomOnClick` property.\r\n   *\r\n   * @return True if zoomOnClick property is set.\r\n   */\n\n\n  getZoomOnClick() {\n    return this.zoomOnClick_;\n  }\n  /**\r\n   *  Sets the value of the `zoomOnClick` property.\r\n   *\r\n   *  @param zoomOnClick The value of the zoomOnClick property.\r\n   */\n\n\n  setZoomOnClick(zoomOnClick) {\n    this.zoomOnClick_ = zoomOnClick;\n  }\n  /**\r\n   * Returns the value of the `averageCenter` property.\r\n   *\r\n   * @return True if averageCenter property is set.\r\n   */\n\n\n  getAverageCenter() {\n    return this.averageCenter_;\n  }\n  /**\r\n   *  Sets the value of the `averageCenter` property.\r\n   *\r\n   *  @param averageCenter The value of the averageCenter property.\r\n   */\n\n\n  setAverageCenter(averageCenter) {\n    this.averageCenter_ = averageCenter;\n  }\n  /**\r\n   * Returns the value of the `ignoreHidden` property.\r\n   *\r\n   * @return True if ignoreHidden property is set.\r\n   */\n\n\n  getIgnoreHidden() {\n    return this.ignoreHidden_;\n  }\n  /**\r\n   *  Sets the value of the `ignoreHidden` property.\r\n   *\r\n   *  @param ignoreHidden The value of the ignoreHidden property.\r\n   */\n\n\n  setIgnoreHidden(ignoreHidden) {\n    this.ignoreHidden_ = ignoreHidden;\n  }\n  /**\r\n   * Returns the value of the `enableRetinaIcons` property.\r\n   *\r\n   * @return True if enableRetinaIcons property is set.\r\n   */\n\n\n  getEnableRetinaIcons() {\n    return this.enableRetinaIcons_;\n  }\n  /**\r\n   *  Sets the value of the `enableRetinaIcons` property.\r\n   *\r\n   *  @param enableRetinaIcons The value of the enableRetinaIcons property.\r\n   */\n\n\n  setEnableRetinaIcons(enableRetinaIcons) {\n    this.enableRetinaIcons_ = enableRetinaIcons;\n  }\n  /**\r\n   * Returns the value of the `imageExtension` property.\r\n   *\r\n   * @return The value of the imageExtension property.\r\n   */\n\n\n  getImageExtension() {\n    return this.imageExtension_;\n  }\n  /**\r\n   *  Sets the value of the `imageExtension` property.\r\n   *\r\n   *  @param imageExtension The value of the imageExtension property.\r\n   */\n\n\n  setImageExtension(imageExtension) {\n    this.imageExtension_ = imageExtension;\n  }\n  /**\r\n   * Returns the value of the `imagePath` property.\r\n   *\r\n   * @return The value of the imagePath property.\r\n   */\n\n\n  getImagePath() {\n    return this.imagePath_;\n  }\n  /**\r\n   *  Sets the value of the `imagePath` property.\r\n   *\r\n   *  @param imagePath The value of the imagePath property.\r\n   */\n\n\n  setImagePath(imagePath) {\n    this.imagePath_ = imagePath;\n  }\n  /**\r\n   * Returns the value of the `imageSizes` property.\r\n   *\r\n   * @return The value of the imageSizes property.\r\n   */\n\n\n  getImageSizes() {\n    return this.imageSizes_;\n  }\n  /**\r\n   *  Sets the value of the `imageSizes` property.\r\n   *\r\n   *  @param imageSizes The value of the imageSizes property.\r\n   */\n\n\n  setImageSizes(imageSizes) {\n    this.imageSizes_ = imageSizes;\n  }\n  /**\r\n   * Returns the value of the `calculator` property.\r\n   *\r\n   * @return the value of the calculator property.\r\n   */\n\n\n  getCalculator() {\n    return this.calculator_;\n  }\n  /**\r\n   * Sets the value of the `calculator` property.\r\n   *\r\n   * @param calculator The value of the calculator property.\r\n   */\n\n\n  setCalculator(calculator) {\n    this.calculator_ = calculator;\n  }\n  /**\r\n   * Returns the value of the `batchSizeIE` property.\r\n   *\r\n   * @return the value of the batchSizeIE property.\r\n   */\n\n\n  getBatchSizeIE() {\n    return this.batchSizeIE_;\n  }\n  /**\r\n   * Sets the value of the `batchSizeIE` property.\r\n   *\r\n   *  @param batchSizeIE The value of the batchSizeIE property.\r\n   */\n\n\n  setBatchSizeIE(batchSizeIE) {\n    this.batchSizeIE_ = batchSizeIE;\n  }\n  /**\r\n   * Returns the value of the `clusterClass` property.\r\n   *\r\n   * @return the value of the clusterClass property.\r\n   */\n\n\n  getClusterClass() {\n    return this.clusterClass_;\n  }\n  /**\r\n   * Sets the value of the `clusterClass` property.\r\n   *\r\n   *  @param clusterClass The value of the clusterClass property.\r\n   */\n\n\n  setClusterClass(clusterClass) {\n    this.clusterClass_ = clusterClass;\n  }\n  /**\r\n   *  Returns the array of markers managed by the clusterer.\r\n   *\r\n   *  @return The array of markers managed by the clusterer.\r\n   */\n\n\n  getMarkers() {\n    return this.markers_;\n  }\n  /**\r\n   *  Returns the number of markers managed by the clusterer.\r\n   *\r\n   *  @return The number of markers.\r\n   */\n\n\n  getTotalMarkers() {\n    return this.markers_.length;\n  }\n  /**\r\n   * Returns the current array of clusters formed by the clusterer.\r\n   *\r\n   * @return The array of clusters formed by the clusterer.\r\n   */\n\n\n  getClusters() {\n    return this.clusters_;\n  }\n  /**\r\n   * Returns the number of clusters formed by the clusterer.\r\n   *\r\n   * @return The number of clusters formed by the clusterer.\r\n   */\n\n\n  getTotalClusters() {\n    return this.clusters_.length;\n  }\n  /**\r\n   * Adds a marker to the clusterer. The clusters are redrawn unless\r\n   *  `nodraw` is set to `true`.\r\n   *\r\n   * @param marker The marker to add.\r\n   * @param nodraw Set to `true` to prevent redrawing.\r\n   */\n\n\n  addMarker(marker, nodraw) {\n    this.pushMarkerTo_(marker);\n\n    if (!nodraw) {\n      this.redraw_();\n    }\n  }\n  /**\r\n   * Adds an array of markers to the clusterer. The clusters are redrawn unless\r\n   *  `nodraw` is set to `true`.\r\n   *\r\n   * @param markers The markers to add.\r\n   * @param nodraw Set to `true` to prevent redrawing.\r\n   */\n\n\n  addMarkers(markers, nodraw) {\n    for (const key in markers) {\n      if (Object.prototype.hasOwnProperty.call(markers, key)) {\n        this.pushMarkerTo_(markers[key]);\n      }\n    }\n\n    if (!nodraw) {\n      this.redraw_();\n    }\n  }\n  /**\r\n   * Pushes a marker to the clusterer.\r\n   *\r\n   * @param marker The marker to add.\r\n   */\n\n\n  pushMarkerTo_(marker) {\n    // If the marker is draggable add a listener so we can update the clusters on the dragend:\n    if (marker.getDraggable()) {\n      google.maps.event.addListener(marker, \"dragend\", () => {\n        if (this.ready_) {\n          marker.isAdded = false;\n          this.repaint();\n        }\n      });\n    }\n\n    marker.isAdded = false;\n    this.markers_.push(marker);\n  }\n  /**\r\n   * Removes a marker from the cluster.  The clusters are redrawn unless\r\n   *  `nodraw` is set to `true`. Returns `true` if the\r\n   *  marker was removed from the clusterer.\r\n   *\r\n   * @param marker The marker to remove.\r\n   * @param nodraw Set to `true` to prevent redrawing.\r\n   * @return True if the marker was removed from the clusterer.\r\n   */\n\n\n  removeMarker(marker, nodraw) {\n    const removed = this.removeMarker_(marker);\n\n    if (!nodraw && removed) {\n      this.repaint();\n    }\n\n    return removed;\n  }\n  /**\r\n   * Removes an array of markers from the cluster. The clusters are redrawn unless\r\n   *  `nodraw` is set to `true`. Returns `true` if markers were removed from the clusterer.\r\n   *\r\n   * @param markers The markers to remove.\r\n   * @param nodraw Set to `true` to prevent redrawing.\r\n   * @return True if markers were removed from the clusterer.\r\n   */\n\n\n  removeMarkers(markers, nodraw) {\n    let removed = false;\n\n    for (let i = 0; i < markers.length; i++) {\n      const r = this.removeMarker_(markers[i]);\n      removed = removed || r;\n    }\n\n    if (!nodraw && removed) {\n      this.repaint();\n    }\n\n    return removed;\n  }\n  /**\r\n   * Removes a marker and returns true if removed, false if not.\r\n   *\r\n   * @param marker The marker to remove\r\n   * @return Whether the marker was removed or not\r\n   */\n\n\n  removeMarker_(marker) {\n    let index = -1;\n\n    if (this.markers_.indexOf) {\n      index = this.markers_.indexOf(marker);\n    } else {\n      for (let i = 0; i < this.markers_.length; i++) {\n        if (marker === this.markers_[i]) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false;\n    }\n\n    marker.setMap(null);\n    this.markers_.splice(index, 1); // Remove the marker from the list of managed markers\n\n    return true;\n  }\n  /**\r\n   * Removes all clusters and markers from the map and also removes all markers\r\n   *  managed by the clusterer.\r\n   */\n\n\n  clearMarkers() {\n    this.resetViewport_(true);\n    this.markers_ = [];\n  }\n  /**\r\n   * Recalculates and redraws all the marker clusters from scratch.\r\n   *  Call this after changing any properties.\r\n   */\n\n\n  repaint() {\n    const oldClusters = this.clusters_.slice();\n    this.clusters_ = [];\n    this.resetViewport_(false);\n    this.redraw_(); // Remove the old clusters.\n    // Do it in a timeout to prevent blinking effect.\n\n    setTimeout(function () {\n      for (let i = 0; i < oldClusters.length; i++) {\n        oldClusters[i].remove();\n      }\n    }, 0);\n  }\n  /**\r\n   * Returns the current bounds extended by the grid size.\r\n   *\r\n   * @param bounds The bounds to extend.\r\n   * @return The extended bounds.\r\n   * @ignore\r\n   */\n\n\n  getExtendedBounds(bounds) {\n    const projection = this.getProjection(); // Turn the bounds into latlng.\n\n    const tr = new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng());\n    const bl = new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng()); // Convert the points to pixels and the extend out by the grid size.\n\n    const trPix = projection.fromLatLngToDivPixel(tr);\n    trPix.x += this.gridSize_;\n    trPix.y -= this.gridSize_;\n    const blPix = projection.fromLatLngToDivPixel(bl);\n    blPix.x -= this.gridSize_;\n    blPix.y += this.gridSize_; // Convert the pixel points back to LatLng\n\n    const ne = projection.fromDivPixelToLatLng(trPix);\n    const sw = projection.fromDivPixelToLatLng(blPix); // Extend the bounds to contain the new bounds.\n\n    bounds.extend(ne);\n    bounds.extend(sw);\n    return bounds;\n  }\n  /**\r\n   * Redraws all the clusters.\r\n   */\n\n\n  redraw_() {\n    this.createClusters_(0);\n  }\n  /**\r\n   * Removes all clusters from the map. The markers are also removed from the map\r\n   *  if `hide` is set to `true`.\r\n   *\r\n   * @param hide Set to `true` to also remove the markers from the map.\r\n   */\n\n\n  resetViewport_(hide) {\n    // Remove all the clusters\n    for (let i = 0; i < this.clusters_.length; i++) {\n      this.clusters_[i].remove();\n    }\n\n    this.clusters_ = []; // Reset the markers to not be added and to be removed from the map.\n\n    for (let i = 0; i < this.markers_.length; i++) {\n      const marker = this.markers_[i];\n      marker.isAdded = false;\n\n      if (hide) {\n        marker.setMap(null);\n      }\n    }\n  }\n  /**\r\n   * Calculates the distance between two latlng locations in km.\r\n   *\r\n   * @param p1 The first lat lng point.\r\n   * @param p2 The second lat lng point.\r\n   * @return The distance between the two points in km.\r\n   * @link http://www.movable-type.co.uk/scripts/latlong.html\r\n   */\n\n\n  distanceBetweenPoints_(p1, p2) {\n    const R = 6371; // Radius of the Earth in km\n\n    const dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n    const dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n  /**\r\n   * Determines if a marker is contained in a bounds.\r\n   *\r\n   * @param marker The marker to check.\r\n   * @param bounds The bounds to check against.\r\n   * @return True if the marker is in the bounds.\r\n   */\n\n\n  isMarkerInBounds_(marker, bounds) {\n    return bounds.contains(marker.getPosition());\n  }\n  /**\r\n   * Adds a marker to a cluster, or creates a new cluster.\r\n   *\r\n   * @param marker The marker to add.\r\n   */\n\n\n  addToClosestCluster_(marker) {\n    let distance = 40000; // Some large number\n\n    let clusterToAddTo = null;\n\n    for (let i = 0; i < this.clusters_.length; i++) {\n      const cluster = this.clusters_[i];\n      const center = cluster.getCenter();\n\n      if (center) {\n        const d = this.distanceBetweenPoints_(center, marker.getPosition());\n\n        if (d < distance) {\n          distance = d;\n          clusterToAddTo = cluster;\n        }\n      }\n    }\n\n    if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n      clusterToAddTo.addMarker(marker);\n    } else {\n      const cluster = new Cluster(this);\n      cluster.addMarker(marker);\n      this.clusters_.push(cluster);\n    }\n  }\n  /**\r\n   * Creates the clusters. This is done in batches to avoid timeout errors\r\n   *  in some browsers when there is a huge number of markers.\r\n   *\r\n   * @param iFirst The index of the first marker in the batch of\r\n   *  markers to be added to clusters.\r\n   */\n\n\n  createClusters_(iFirst) {\n    if (!this.ready_) {\n      return;\n    } // Cancel previous batch processing if we're working on the first batch:\n\n\n    if (iFirst === 0) {\n      google.maps.event.trigger(this, \"clusteringbegin\", this);\n\n      if (typeof this.timerRefStatic !== \"undefined\") {\n        clearTimeout(this.timerRefStatic);\n        delete this.timerRefStatic;\n      }\n    } // Get our current map view bounds.\n    // Create a new bounds object so we don't affect the map.\n    //\n    // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:\n\n\n    let mapBounds;\n\n    if (this.getMap().getZoom() > 3) {\n      mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast());\n    } else {\n      mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));\n    }\n\n    const bounds = this.getExtendedBounds(mapBounds);\n    const iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);\n\n    for (let i = iFirst; i < iLast; i++) {\n      const marker = this.markers_[i];\n\n      if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n        if (!this.ignoreHidden_ || this.ignoreHidden_ && marker.getVisible()) {\n          this.addToClosestCluster_(marker);\n        }\n      }\n    }\n\n    if (iLast < this.markers_.length) {\n      this.timerRefStatic = window.setTimeout(() => {\n        this.createClusters_(iLast);\n      }, 0);\n    } else {\n      delete this.timerRefStatic;\n      google.maps.event.trigger(this, \"clusteringend\", this);\n\n      for (let i = 0; i < this.clusters_.length; i++) {\n        this.clusters_[i].updateIcon();\n      }\n    }\n  }\n  /**\r\n   * The default function for determining the label text and style\r\n   * for a cluster icon.\r\n   *\r\n   * @param markers The array of markers represented by the cluster.\r\n   * @param numStyles The number of marker styles available.\r\n   * @return The information resource for the cluster.\r\n   */\n\n\n  static CALCULATOR(markers, numStyles) {\n    let index = 0;\n    const count = markers.length;\n    let dv = count;\n\n    while (dv !== 0) {\n      dv = Math.floor(dv / 10);\n      index++;\n    }\n\n    index = Math.min(index, numStyles);\n    return {\n      text: count.toString(),\n      index: index,\n      title: \"\"\n    };\n  }\n  /**\r\n   * Generates default styles augmented with user passed values.\r\n   * Useful when you want to override some default values but keep untouched\r\n   *\r\n   * @param overrides override default values\r\n   */\n\n\n  static withDefaultStyle(overrides) {\n    return Object.assign({\n      textColor: \"black\",\n      textSize: 11,\n      textDecoration: \"none\",\n      textLineHeight: overrides.height,\n      fontWeight: \"bold\",\n      fontStyle: \"normal\",\n      fontFamily: \"Arial,sans-serif\",\n      backgroundPosition: \"0 0\"\n    }, overrides);\n  }\n\n}\n/**\r\n * The number of markers to process in one batch.\r\n */\n\n\nMarkerClusterer.BATCH_SIZE = 2000;\n/**\r\n * The number of markers to process in one batch (IE only).\r\n */\n\nMarkerClusterer.BATCH_SIZE_IE = 500;\n/**\r\n * The default root name for the marker cluster images.\r\n */\n\nMarkerClusterer.IMAGE_PATH = \"../images/m\";\n/**\r\n * The default extension name for the marker cluster images.\r\n */\n\nMarkerClusterer.IMAGE_EXTENSION = \"png\";\n/**\r\n * The default array of sizes for the marker cluster images.\r\n */\n\nMarkerClusterer.IMAGE_SIZES = [53, 56, 66, 78, 90];\n/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nexport default MarkerClusterer;","map":{"version":3,"mappings":"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","names":["extend","type1","type2","property","prototype","OverlayViewSafe","constructor","google","maps","OverlayView","toCssText","styles","Object","keys","reduce","acc","key","push","join","coercePixels","pixels","undefined","ClusterIcon","cluster_","styles_","setMap","getMap","onAdd","cMouseDownInCluster","cDraggingMapByCluster","mc","getMarkerClusterer","major","minor","version","split","gmVersion","parseInt","div_","document","createElement","visible_","show","getPanes","overlayMouseTarget","appendChild","boundsChangedListener_","event","addListener","addDomListener","e","stopPropagation","trigger","getZoomOnClick","mz","getMaxZoom","theBounds","getBounds","fitBounds","setTimeout","getZoom","setZoom","cancelBubble","onRemove","parentNode","hide","removeListener","clearInstanceListeners","removeChild","draw","pos","getPosFromLatLng_","center_","style","top","y","left","x","display","className","className_","cssText","createCss_","innerHTML","url","getImageElementHtml","getLabelDivHtml","sums_","title","getTitle","ariaLabel","ariaLabelFn","text","divStyle","position","anchorText_","color","textColor","textSize","fontFamily","fontWeight","fontStyle","textDecoration","width","textLineHeight","bp","backgroundPosition","spriteH","replace","spriteV","dimensions","getEnableRetinaIcons","height","Y1","X1","Y2","X2","clip","useStyle","sums","index","Math","max","min","length","anchorText","anchorIcon_","anchorIcon","floor","getClusterClass","setCenter","center","getZIndex","cursor","latlng","getProjection","fromLatLngToDivPixel","Cluster","markerClusterer_","getMinimumClusterSize","getAverageCenter","getStyles","getSize","markers_","getMarkers","getCenter","map_","bounds","LatLngBounds","markers","i","getPosition","remove","clusterIcon_","addMarker","marker","isMarkerAlreadyAdded_","calculateBounds_","averageCenter_","l","lat","lng","LatLng","isAdded","mCount","minClusterSize_","isMarkerInClusterBounds","bounds_","contains","getExtendedBounds","updateIcon","numStyles","getCalculator","indexOf","getOption","options","prop","def","MarkerClusterer","map","zIndex","Marker","MAX_ZINDEX","gridSize","minimumClusterSize","maxZoom","imagePath","IMAGE_PATH","imageExtension","IMAGE_EXTENSION","imageSizes","IMAGE_SIZES","calculator","CALCULATOR","batchSize","BATCH_SIZE","batchSizeIE","BATCH_SIZE_IE","clusterClass","navigator","userAgent","toLowerCase","batchSize_","batchSizeIE_","setupStyles_","addMarkers","activeMap_","ready_","repaint","prevZoom_","listeners_","minZoom","mapTypes","getMapTypeId","zoom","resetViewport_","redraw_","clusters_","imageSizes_","size","withDefaultStyle","imagePath_","imageExtension_","fitMapToMarkers","padding","getVisible","getIgnoreHidden","getGridSize","gridSize_","setGridSize","setMinimumClusterSize","maxZoom_","setMaxZoom","zIndex_","setZIndex","setStyles","title_","setTitle","zoomOnClick_","setZoomOnClick","zoomOnClick","setAverageCenter","averageCenter","ignoreHidden_","setIgnoreHidden","ignoreHidden","enableRetinaIcons_","setEnableRetinaIcons","enableRetinaIcons","getImageExtension","setImageExtension","getImagePath","setImagePath","getImageSizes","setImageSizes","calculator_","setCalculator","getBatchSizeIE","setBatchSizeIE","clusterClass_","setClusterClass","getTotalMarkers","getClusters","getTotalClusters","nodraw","pushMarkerTo_","hasOwnProperty","call","getDraggable","removeMarker","removed","removeMarker_","removeMarkers","r","splice","clearMarkers","oldClusters","slice","projection","tr","getNorthEast","bl","getSouthWest","trPix","blPix","ne","fromDivPixelToLatLng","sw","createClusters_","distanceBetweenPoints_","p1","p2","R","dLat","PI","dLon","a","sin","cos","c","atan2","sqrt","isMarkerInBounds_","addToClosestCluster_","distance","clusterToAddTo","cluster","d","iFirst","timerRefStatic","clearTimeout","mapBounds","iLast","window","count","dv","toString","overrides"],"sources":["C:\\Users\\53976212857.INFOSCS\\Desktop\\Block\\blocktrcaking\\node_modules\\@google\\markerclustererplus\\src\\overlay-view-safe.ts","C:\\Users\\53976212857.INFOSCS\\Desktop\\Block\\blocktrcaking\\node_modules\\@google\\markerclustererplus\\src\\cluster-icon.ts","C:\\Users\\53976212857.INFOSCS\\Desktop\\Block\\blocktrcaking\\node_modules\\@google\\markerclustererplus\\src\\cluster.ts","C:\\Users\\53976212857.INFOSCS\\Desktop\\Block\\blocktrcaking\\node_modules\\@google\\markerclustererplus\\src\\markerclusterer.ts","C:\\Users\\53976212857.INFOSCS\\Desktop\\Block\\blocktrcaking\\node_modules\\@google\\markerclustererplus\\src\\index.ts"],"sourcesContent":["/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OverlayViewSafe extends google.maps.OverlayView {}\n\n/**\n * Extends an object's prototype by another's.\n *\n * @param type1 The Type to be extended.\n * @param type2 The Type to extend with.\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1: any, type2: any): void {\n  // eslint-disable-next-line prefer-const\n  for (let property in type2.prototype) {\n    type1.prototype[property] = type2.prototype[property];\n  }\n}\n\n/**\n * @ignore\n */\nexport class OverlayViewSafe {\n  constructor() {\n    // MarkerClusterer implements google.maps.OverlayView interface. We use the\n    // extend function to extend MarkerClusterer with google.maps.OverlayView\n    // because it might not always be available when the code is defined so we\n    // look for it at the last possible moment. If it doesn't exist now then\n    // there is no point going ahead :)\n    extend(OverlayViewSafe, google.maps.OverlayView);\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This class represents the object for values in the `styles` array passed\n * to the {@link MarkerClusterer} constructor. The element in this array that is used to\n * style the cluster icon is determined by calling the `calculator` function.\n */\nimport { Cluster } from \"./cluster\";\nimport { OverlayViewSafe } from \"./overlay-view-safe\";\n\n/**\n *\n * @hidden\n */\nfunction toCssText(styles: { [key: string]: string }): string {\n  return Object.keys(styles)\n    .reduce((acc, key) => {\n      if (styles[key]) {\n        acc.push(key + \":\" + styles[key]);\n      }\n      return acc;\n    }, [])\n    .join(\";\");\n}\n\n/**\n *\n * @hidden\n */\nfunction coercePixels(pixels: number): string {\n  return pixels ? pixels + \"px\" : undefined;\n}\n\nexport interface ClusterIconStyle {\n  /** The URL of the cluster icon image file. If not set, img element will not be created */\n  url?: string;\n  /** The name of the CSS class defining styles for the cluster markers. */\n  className?: string;\n  /** Height The display height (in pixels) of the cluster icon. Required. */\n  height: number;\n  /** Width The display width (in pixels) of the cluster icon. Required. */\n  width: number;\n  /**\n   * The position (in pixels) from the center of the cluster icon to\n   * where the text label is to be centered and drawn. The format is `[yoffset, xoffset]`\n   * where `yoffset` increases as you go down from center and `xoffset`\n   * increases to the right of center. The default is `[0, 0]`.\n   */\n  anchorText?: [number, number];\n  /**\n   * The anchor position (in pixels) of the cluster icon. This is the\n   * spot on the cluster icon that is to be aligned with the cluster position. The format is\n   * `[yoffset, xoffset]` where `yoffset` increases as you go down and\n   * `xoffset` increases to the right of the top-left corner of the icon. The default\n   * anchor position is the center of the cluster icon.\n   */\n  anchorIcon?: [number, number];\n  /**\n   * The color of the label text shown on the cluster icon.\n   * @default `\"black\"`\n   */\n  textColor?: string;\n  /** The size (in pixels) of the label text shown on the cluster icon.\n   * @default `11`\n   */\n  textSize?: number;\n\n  /** The line height (in pixels) of the label text shown on the cluster icon.\n   * @default the same as cluster icon height\n   */\n  textLineHeight?: number;\n  /**\n   * The value of the CSS `text-decoration`\n   * property for the label text shown on the cluster icon.\n   *\n   * @default `\"none\"`\n   */\n  textDecoration?: string;\n  /**\n   * The value of the CSS `font-weight`\n   * property for the label text shown on the cluster icon.\n   *\n   *  @default `\"bold\"`\n   */\n  fontWeight?: string;\n  /**\n   *  The value of the CSS `font-style`\n   *  property for the label text shown on the cluster icon.\n   *\n   *  @default `\"normal\"`\n   */\n  fontStyle?: string;\n  /**\n   *  The value of the CSS `font-family`\n   *  property for the label text shown on the cluster icon.\n   *  @default `\"Arial,sans-serif\"`\n   */\n  fontFamily?: string;\n  /**\n   * The position of the cluster icon image\n   * within the image defined by `url`. The format is `\"xpos ypos\"`\n   * (the same format as for the CSS `background-position` property). You must set\n   * this property appropriately when the image defined by `url` represents a sprite\n   * containing multiple images. Note that the position <i>must</i> be specified in px units.\n   *\n   * @default `\"0 0\"`\n   */\n  backgroundPosition?: string;\n}\n\n/**\n * @description This is an object containing general information about a cluster icon. This is\n *  the object that a `calculator` function returns.\n */\nexport interface ClusterIconInfo {\n  /**\n   * The text of the label to be shown on the cluster icon.\n   */\n  text: string;\n  /**\n   * The index plus 1 of the element in the `styles`\n   */\n  index: number;\n  /**\n   * The tooltip to display when the mouse moves over the cluster icon.\n   * If this value is `undefined` or `\"\"`, `title` is set to the\n   * value of the `title` property passed to the MarkerClusterer.\n   */\n  title: string;\n}\n\n/**\n * A cluster icon.\n */\nexport class ClusterIcon extends OverlayViewSafe {\n  private className_: string;\n  private center_: google.maps.LatLng = null;\n  private div_: HTMLDivElement = null;\n  private sums_: ClusterIconInfo = null;\n  private visible_ = false;\n\n  private style: ClusterIconStyle = null;\n\n  private anchorText_: [number, number];\n  private anchorIcon_: [number, number];\n\n  private boundsChangedListener_: google.maps.MapsEventListener;\n\n  /**\n   * @param cluster_ The cluster with which the icon is to be associated.\n   * @param styles_ An array of {@link ClusterIconStyle} defining the cluster icons\n   *  to use for various cluster sizes.\n   */\n  constructor(private cluster_: Cluster, private styles_: ClusterIconStyle[]) {\n    super();\n\n    this.setMap(cluster_.getMap()); // Note: this causes onAdd to be called\n  }\n\n  /**\n   * Adds the icon to the DOM.\n   */\n  onAdd(): void {\n    let cMouseDownInCluster: boolean;\n    let cDraggingMapByCluster: boolean;\n\n    const mc = this.cluster_.getMarkerClusterer();\n\n    const [major, minor] = google.maps.version.split(\".\");\n\n    const gmVersion = parseInt(major, 10) * 100 + parseInt(minor, 10);\n\n    this.div_ = document.createElement(\"div\");\n    if (this.visible_) {\n      this.show();\n    }\n\n    this.getPanes().overlayMouseTarget.appendChild(this.div_);\n\n    // Fix for Issue 157\n    this.boundsChangedListener_ = google.maps.event.addListener(\n      this.getMap(),\n      \"bounds_changed\",\n      function() {\n        cDraggingMapByCluster = cMouseDownInCluster;\n      }\n    );\n\n    google.maps.event.addDomListener(this.div_, \"mousedown\", () => {\n      cMouseDownInCluster = true;\n      cDraggingMapByCluster = false;\n    });\n\n    // March 1, 2018: Fix for this 3.32 exp bug, https://issuetracker.google.com/issues/73571522\n    // But it doesn't work with earlier releases so do a version check.\n    if (gmVersion >= 332) {\n      // Ugly version-dependent code\n      google.maps.event.addDomListener(this.div_, \"touchstart\", e => {\n        e.stopPropagation();\n      });\n    }\n\n    google.maps.event.addDomListener(this.div_, \"click\", e => {\n      cMouseDownInCluster = false;\n      if (!cDraggingMapByCluster) {\n        /**\n         * This event is fired when a cluster marker is clicked.\n         * @name MarkerClusterer#click\n         * @param {Cluster} c The cluster that was clicked.\n         * @event\n         */\n        google.maps.event.trigger(mc, \"click\", this.cluster_);\n        google.maps.event.trigger(mc, \"clusterclick\", this.cluster_); // deprecated name\n\n        // The default click handler follows. Disable it by setting\n        // the zoomOnClick property to false.\n        if (mc.getZoomOnClick()) {\n          // Zoom into the cluster.\n          const mz = mc.getMaxZoom();\n          const theBounds = this.cluster_.getBounds();\n          (mc.getMap() as google.maps.Map).fitBounds(theBounds);\n          // There is a fix for Issue 170 here:\n          setTimeout(function() {\n            (mc.getMap() as google.maps.Map).fitBounds(theBounds);\n            // Don't zoom beyond the max zoom level\n            if (mz !== null && mc.getMap().getZoom() > mz) {\n              mc.getMap().setZoom(mz + 1);\n            }\n          }, 100);\n        }\n\n        // Prevent event propagation to the map:\n        e.cancelBubble = true;\n        if (e.stopPropagation) {\n          e.stopPropagation();\n        }\n      }\n    });\n\n    google.maps.event.addDomListener(this.div_, \"mouseover\", () => {\n      /**\n       * This event is fired when the mouse moves over a cluster marker.\n       * @name MarkerClusterer#mouseover\n       * @param {Cluster} c The cluster that the mouse moved over.\n       * @event\n       */\n      google.maps.event.trigger(mc, \"mouseover\", this.cluster_);\n    });\n\n    google.maps.event.addDomListener(this.div_, \"mouseout\", () => {\n      /**\n       * This event is fired when the mouse moves out of a cluster marker.\n       * @name MarkerClusterer#mouseout\n       * @param {Cluster} c The cluster that the mouse moved out of.\n       * @event\n       */\n      google.maps.event.trigger(mc, \"mouseout\", this.cluster_);\n    });\n  }\n\n  /**\n   * Removes the icon from the DOM.\n   */\n  onRemove(): void {\n    if (this.div_ && this.div_.parentNode) {\n      this.hide();\n      google.maps.event.removeListener(this.boundsChangedListener_);\n      google.maps.event.clearInstanceListeners(this.div_);\n      this.div_.parentNode.removeChild(this.div_);\n      this.div_ = null;\n    }\n  }\n\n  /**\n   * Draws the icon.\n   */\n  draw(): void {\n    if (this.visible_) {\n      const pos = this.getPosFromLatLng_(this.center_);\n      this.div_.style.top = pos.y + \"px\";\n      this.div_.style.left = pos.x + \"px\";\n    }\n  }\n\n  /**\n   * Hides the icon.\n   */\n  hide(): void {\n    if (this.div_) {\n      this.div_.style.display = \"none\";\n    }\n    this.visible_ = false;\n  }\n\n  /**\n   * Positions and shows the icon.\n   */\n  show(): void {\n    if (this.div_) {\n      this.div_.className = this.className_;\n      this.div_.style.cssText = this.createCss_(\n        this.getPosFromLatLng_(this.center_)\n      );\n\n      this.div_.innerHTML =\n        (this.style.url ? this.getImageElementHtml() : \"\") +\n        this.getLabelDivHtml();\n\n      if (typeof this.sums_.title === \"undefined\" || this.sums_.title === \"\") {\n        this.div_.title = this.cluster_.getMarkerClusterer().getTitle();\n      } else {\n        this.div_.title = this.sums_.title;\n      }\n      this.div_.style.display = \"\";\n    }\n    this.visible_ = true;\n  }\n\n  private getLabelDivHtml(): string {\n    const mc = this.cluster_.getMarkerClusterer();\n    const ariaLabel = mc.ariaLabelFn(this.sums_.text);\n\n    const divStyle: { [key: string]: string } = {\n      position: \"absolute\",\n      top: coercePixels(this.anchorText_[0]),\n      left: coercePixels(this.anchorText_[1]),\n      color: this.style.textColor,\n      \"font-size\": coercePixels(this.style.textSize),\n      \"font-family\": this.style.fontFamily,\n      \"font-weight\": this.style.fontWeight,\n      \"font-style\": this.style.fontStyle,\n      \"text-decoration\": this.style.textDecoration,\n      \"text-align\": \"center\",\n      width: coercePixels(this.style.width),\n      \"line-height\": coercePixels(this.style.textLineHeight)\n    };\n\n    return `\n<div aria-label=\"${ariaLabel}\" style=\"${toCssText(divStyle)}\" tabindex=\"0\">\n  <span aria-hidden=\"true\">${this.sums_.text}</span>\n</div>\n`;\n  }\n\n  private getImageElementHtml(): string {\n    // NOTE: values must be specified in px units\n    const bp = (this.style.backgroundPosition || \"0 0\").split(\" \");\n    const spriteH = parseInt(bp[0].replace(/^\\s+|\\s+$/g, \"\"), 10);\n    const spriteV = parseInt(bp[1].replace(/^\\s+|\\s+$/g, \"\"), 10);\n\n    let dimensions: { [key: string]: string } = {};\n\n    if (this.cluster_.getMarkerClusterer().getEnableRetinaIcons()) {\n      dimensions = {\n        width: coercePixels(this.style.width),\n        height: coercePixels(this.style.height)\n      };\n    } else {\n      const [Y1, X1, Y2, X2] = [\n        -1 * spriteV,\n        -1 * spriteH + this.style.width,\n        -1 * spriteV + this.style.height,\n        -1 * spriteH\n      ];\n      dimensions = {\n        clip: `rect(${Y1}px, ${X1}px, ${Y2}px, ${X2}px)`\n      };\n    }\n\n    const cssText = toCssText({\n      position: \"absolute\",\n      top: coercePixels(spriteV),\n      left: coercePixels(spriteH),\n      ...dimensions\n    });\n\n    return `<img alt=\"${this.sums_.text}\" aria-hidden=\"true\" src=\"${this.style.url}\" style=\"${cssText}\"/>`;\n  }\n\n  /**\n   * Sets the icon styles to the appropriate element in the styles array.\n   *\n   * @ignore\n   * @param sums The icon label text and styles index.\n   */\n  useStyle(sums: ClusterIconInfo): void {\n    this.sums_ = sums;\n    let index = Math.max(0, sums.index - 1);\n    index = Math.min(this.styles_.length - 1, index);\n    this.style = this.styles_[index];\n\n    this.anchorText_ = this.style.anchorText || [0, 0];\n    this.anchorIcon_ = this.style.anchorIcon || [\n      Math.floor(this.style.height / 2),\n      Math.floor(this.style.width / 2)\n    ];\n\n    this.className_ =\n      this.cluster_.getMarkerClusterer().getClusterClass() +\n      \" \" +\n      (this.style.className || \"cluster-\" + index);\n  }\n\n  /**\n   * Sets the position at which to center the icon.\n   *\n   * @param center The latlng to set as the center.\n   */\n  setCenter(center: google.maps.LatLng): void {\n    this.center_ = center;\n  }\n\n  /**\n   * Creates the `cssText` style parameter based on the position of the icon.\n   *\n   * @param pos The position of the icon.\n   * @return The CSS style text.\n   */\n  private createCss_(pos: google.maps.Point): string {\n    return toCssText({\n      \"z-index\": `${this.cluster_.getMarkerClusterer().getZIndex()}`,\n      top: coercePixels(pos.y),\n      left: coercePixels(pos.x),\n      width: coercePixels(this.style.width),\n      height: coercePixels(this.style.height),\n      cursor: \"pointer\",\n      position: \"absolute\",\n      \"-webkit-user-select\": \"none\",\n      \"-khtml-user-select\": \"none\",\n      \"-moz-user-select\": \"none\",\n      \"-o-user-select\": \"none\",\n      \"user-select\": \"none\"\n    });\n  }\n\n  /**\n   * Returns the position at which to place the DIV depending on the latlng.\n   *\n   * @param latlng The position in latlng.\n   * @return The position in pixels.\n   */\n  private getPosFromLatLng_(latlng: google.maps.LatLng): google.maps.Point {\n    const pos = this.getProjection().fromLatLngToDivPixel(latlng);\n    pos.x = Math.floor(pos.x - this.anchorIcon_[1]);\n    pos.y = Math.floor(pos.y - this.anchorIcon_[0]);\n    return pos;\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MarkerClusterer, ClusterAugmentedMarker } from \"./markerclusterer\";\nimport { ClusterIcon } from \"./cluster-icon\";\n\n/**\n * Creates a single cluster that manages a group of proximate markers.\n *  Used internally, do not call this constructor directly.\n */\nexport class Cluster {\n  private map_ = this.markerClusterer_.getMap() as google.maps.Map;\n  private minClusterSize_: number = this.markerClusterer_.getMinimumClusterSize();\n  private averageCenter_: boolean = this.markerClusterer_.getAverageCenter();\n  private markers_: ClusterAugmentedMarker[] = []; // TODO: type;\n  private center_: google.maps.LatLng = null;\n  private bounds_: google.maps.LatLngBounds = null;\n  private clusterIcon_ = new ClusterIcon(\n    this,\n    this.markerClusterer_.getStyles()\n  );\n\n  /**\n   *\n   * @param markerClusterer_ The `MarkerClusterer` object with which this\n   *  cluster is associated.\n   */\n  constructor(private markerClusterer_: MarkerClusterer) {}\n\n  /**\n   * Returns the number of markers managed by the cluster. You can call this from\n   * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\n   *\n   * @return The number of markers in the cluster.\n   */\n  public getSize(): number {\n    return this.markers_.length;\n  }\n\n  /**\n   * Returns the array of markers managed by the cluster. You can call this from\n   * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\n   *\n   * @return The array of markers in the cluster.\n   */\n  public getMarkers(): google.maps.Marker[] {\n    return this.markers_;\n  }\n\n  /**\n   * Returns the center of the cluster. You can call this from\n   * a `click`, `mouseover`, or `mouseout` event handler\n   * for the `MarkerClusterer` object.\n   *\n   * @return The center of the cluster.\n   */\n  public getCenter(): google.maps.LatLng {\n    return this.center_;\n  }\n\n  /**\n   * Returns the map with which the cluster is associated.\n   *\n   * @return The map.\n   * @ignore\n   */\n  public getMap(): google.maps.Map {\n    return this.map_;\n  }\n\n  /**\n   * Returns the `MarkerClusterer` object with which the cluster is associated.\n   *\n   * @return The associated marker clusterer.\n   * @ignore\n   */\n  public getMarkerClusterer(): MarkerClusterer {\n    return this.markerClusterer_;\n  }\n\n  /**\n   * Returns the bounds of the cluster.\n   *\n   * @return the cluster bounds.\n   * @ignore\n   */\n  public getBounds(): google.maps.LatLngBounds {\n    const bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n    const markers = this.getMarkers();\n    for (let i = 0; i < markers.length; i++) {\n      bounds.extend(markers[i].getPosition());\n    }\n    return bounds;\n  }\n\n  /**\n   * Removes the cluster from the map.\n   *\n   * @ignore\n   */\n  public remove(): void {\n    this.clusterIcon_.setMap(null);\n    this.markers_ = [];\n    delete this.markers_;\n  }\n\n  /**\n   * Adds a marker to the cluster.\n   *\n   * @param marker The marker to be added.\n   * @return True if the marker was added.\n   * @ignore\n   */\n  public addMarker(\n    marker: google.maps.Marker & { isAdded?: boolean }\n  ): boolean {\n    if (this.isMarkerAlreadyAdded_(marker)) {\n      return false;\n    }\n\n    if (!this.center_) {\n      this.center_ = marker.getPosition();\n      this.calculateBounds_();\n    } else {\n      if (this.averageCenter_) {\n        const l = this.markers_.length + 1;\n        const lat =\n          (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;\n        const lng =\n          (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;\n        this.center_ = new google.maps.LatLng(lat, lng);\n        this.calculateBounds_();\n      }\n    }\n\n    marker.isAdded = true;\n    this.markers_.push(marker);\n\n    const mCount = this.markers_.length;\n    const mz = this.markerClusterer_.getMaxZoom();\n    if (mz !== null && this.map_.getZoom() > mz) {\n      // Zoomed in past max zoom, so show the marker.\n      if (marker.getMap() !== this.map_) {\n        marker.setMap(this.map_);\n      }\n    } else if (mCount < this.minClusterSize_) {\n      // Min cluster size not reached so show the marker.\n      if (marker.getMap() !== this.map_) {\n        marker.setMap(this.map_);\n      }\n    } else if (mCount === this.minClusterSize_) {\n      // Hide the markers that were showing.\n      for (let i = 0; i < mCount; i++) {\n        this.markers_[i].setMap(null);\n      }\n    } else {\n      marker.setMap(null);\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines if a marker lies within the cluster's bounds.\n   *\n   * @param marker The marker to check.\n   * @return True if the marker lies in the bounds.\n   * @ignore\n   */\n  public isMarkerInClusterBounds(marker: google.maps.Marker): boolean {\n    return this.bounds_.contains(marker.getPosition());\n  }\n\n  /**\n   * Calculates the extended bounds of the cluster with the grid.\n   */\n  private calculateBounds_(): void {\n    const bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n    this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n  }\n\n  /**\n   * Updates the cluster icon.\n   */\n  public updateIcon(): void {\n    const mCount = this.markers_.length;\n    const mz = this.markerClusterer_.getMaxZoom();\n\n    if (mz !== null && this.map_.getZoom() > mz) {\n      this.clusterIcon_.hide();\n      return;\n    }\n\n    if (mCount < this.minClusterSize_) {\n      // Min cluster size not yet reached.\n      this.clusterIcon_.hide();\n      return;\n    }\n\n    const numStyles = this.markerClusterer_.getStyles().length;\n    const sums = this.markerClusterer_.getCalculator()(\n      this.markers_,\n      numStyles\n    );\n    this.clusterIcon_.setCenter(this.center_);\n    this.clusterIcon_.useStyle(sums);\n    this.clusterIcon_.show();\n  }\n\n  /**\n   * Determines if a marker has already been added to the cluster.\n   *\n   * @param marker The marker to check.\n   * @return True if the marker has already been added.\n   */\n  private isMarkerAlreadyAdded_(marker: google.maps.Marker): boolean {\n    if (this.markers_.indexOf) {\n      return this.markers_.indexOf(marker) !== -1;\n    } else {\n      for (let i = 0; i < this.markers_.length; i++) {\n        if (marker === this.markers_[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @name MarkerClustererPlus for Google Maps V3\n * @author Gary Little\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of markers.\n * <p>\n * This is an enhanced V3 implementation of the V2 MarkerClusterer by Xiaoxi Wu. It is\n * based on the V3 MarkerClusterer port by Luke Mahe. MarkerClustererPlus was created\n * by Gary Little.\n * <p>\n * v2.0 release: MarkerClustererPlus v2.0 is backward compatible with MarkerClusterer v1.0. It\n *  adds support for the `ignoreHidden`, `title`, `batchSizeIE`,\n *  and `calculator` properties as well as support for four more events. It also allows\n *  greater control over the styling of the text that appears on the cluster marker. The\n *  documentation has been significantly improved and the overall code has been simplified and\n *  polished. Very large numbers of markers can now be managed without causing Javascript timeout\n *  errors on Internet Explorer. Note that the name of the `clusterclick` event has been\n *  deprecated. The new name is `click`, so please change your application code now.\n */\n\nimport { ClusterIconInfo, ClusterIconStyle } from \"./cluster-icon\";\n\nimport { Cluster } from \"./cluster\";\nimport { OverlayViewSafe } from \"./overlay-view-safe\";\n\n/**\n * @param text The text attribute of the cluster\n */\ntype AriaLabelFn = (text: string) => string;\n\nexport type Calculator = (\n  markers: google.maps.Marker[],\n  clusterIconStylesCount: number\n) => ClusterIconInfo;\n\nexport interface ClusterAugmentedMarker extends google.maps.Marker {\n  isAdded?: boolean;\n}\n\n/**\n * This event is fired on the {@link MarkerClusterer} instance when the `MarkerClusterer` stops clustering markers.\n *\n * Example:\n * ```typescript\n *  mc.addListener('clusteringend', (mc: MarkerClusterer) => {})\n * ```\n *\n * @param mc The MarkerClusterer whose markers are being clustered.\n * @event clusteringend\n */\nexport declare function clusteringend(mc: MarkerClusterer): void;\n\n/**\n * This event is fired on the {@link MarkerClusterer} instance when the `MarkerClusterer` begins clustering markers.\n *\n * Example:\n * ```typescript\n *  mc.addListener('clusteringbegin', (mc: MarkerClusterer) => {})\n * ```\n *\n * @param mc The MarkerClusterer whose markers are being clustered.\n * @event clusteringbegin\n */\nexport declare function clusteringbegin(mc: MarkerClusterer): void;\n\n/**\n * Optional parameter passed to the {@link MarkerClusterer} constructor.\n */\nexport interface MarkerClustererOptions {\n  /**\n   * The grid size of a cluster in pixels. The grid is a square.\n   *\n   * @default `60`\n   */\n  gridSize?: number;\n  /**\n   * The maximum zoom level at which clustering is enabled or\n   * `null` if clustering is to be enabled at all zoom levels.\n   *\n   * @default `null`\n   */\n  maxZoom?: number;\n\n  /**\n   * Whether to zoom the map when a cluster marker is\n   * clicked. You may want to set this to `false` if you have installed a handler\n   * for the `click` event and it deals with zooming on its own.\n   *\n   * @default `true`\n   */\n  zoomOnClick?: boolean;\n  /***\n   * Whether the position of a cluster marker should be\n   * the average position of all markers in the cluster. If set to `false`, the\n   * cluster marker is positioned at the location of the first marker added to the cluster.\n   *\n   * @default `false`\n   */\n  averageCenter?: boolean;\n  /**\n   * The minimum number of markers needed in a cluster\n   * before the markers are hidden and a cluster marker appears.\n   *\n   * @default `2`\n   */\n  minimumClusterSize?: number;\n\n  /**\n   *  the z-index of a cluster.\n   *\n   *  @default `google.maps.Marker.MAX_ZINDEX + 1`\n   */\n  zIndex?: number;\n\n  /**\n   * Whether to ignore hidden markers in clusters. You\n   * may want to set this to `true` to ensure that hidden markers are not included\n   * in the marker count that appears on a cluster marker (this count is the value of the\n   * `text` property of the result returned by the default  {@link calculator}).\n   * If set to `true` and you change the visibility of a marker being clustered, be\n   * sure to also call {@link MarkerClusterer#repaint()}.\n   *\n   * @default `false`\n   */\n  ignoreHidden?: boolean;\n  /**\n   * The tooltip to display when the mouse moves over a cluster\n   * marker. (Alternatively, you can use a custom `calculator` function to specify a\n   * different tooltip for each cluster marker.)\n   *\n   * @default `\"\"`\n   */\n  title?: string;\n  /**\n   * The function used to determine\n   * the text to be displayed on a cluster marker and the index indicating which style to use\n   * for the cluster marker. The input parameters for the function are (1) the array of markers\n   * represented by a cluster marker and (2) the number of cluster icon styles. It returns a\n   * {@link ClusterIconInfo} object. The default `calculator` returns a\n   * `text` property which is the number of markers in the cluster and an\n   * `index` property which is one higher than the lowest integer such that\n   * `10^i` exceeds the number of markers in the cluster, or the size of the styles\n   * array, whichever is less. The `styles` array element used has an index of\n   * `index` minus 1. For example, the default `calculator` returns a\n   * `text` value of `\"125\"` and an `index` of `3`\n   * for a cluster icon representing 125 markers so the element used in the `styles`\n   * array is `2`. A `calculator` may also return a `title`\n   * property that contains the text of the tooltip to be used for the cluster marker. If\n   * `title` is not defined, the tooltip is set to the value of the `title`\n   * property for the MarkerClusterer.\n   *\n   * @default {@link MarkerClusterer.CALCULATOR}\n   */\n  calculator?: Calculator;\n  /**\n   * The name of the CSS class defining general styles\n   * for the cluster markers. Use this class to define CSS styles that are not set up by the code\n   * that processes the `styles` array.\n   *\n   * @default `\"cluster\"`\n   */\n  clusterClass?: string;\n  /**\n   * An array of {@link ClusterIconStyle} elements defining the styles\n   * of the cluster markers to be used. The element to be used to style a given cluster marker\n   * is determined by the function defined by the `calculator` property.\n   * The default is an array of {@link ClusterIconStyle} elements whose properties are derived\n   * from the values for `imagePath`, `imageExtension`, and `imageSizes`.\n   *\n   * @default `styles`\n   */\n  styles?: ClusterIconStyle[];\n  /**\n   * Whether to allow the use of cluster icons that\n   * have sizes that are some multiple (typically double) of their actual display size. Icons such\n   * as these look better when viewed on high-resolution monitors such as Apple's Retina displays.\n   * Note: if this property is `true`, sprites cannot be used as cluster icons.\n   *\n   * @default `false`\n   */\n  enableRetinaIcons?: boolean;\n  /**\n   * Set this property to the number of markers to be processed in a single batch when using\n   * a browser other than Internet Explorer (for Internet Explorer, use the batchSizeIE property instead).\n   *\n   * @default `MarkerClusterer.BATCH_SIZE`\n   */\n  batchSize?: number;\n  /**\n   * When Internet Explorer is\n   * being used, markers are processed in several batches with a small delay inserted between\n   * each batch in an attempt to avoid Javascript timeout errors. Set this property to the\n   * number of markers to be processed in a single batch; select as high a number as you can\n   * without causing a timeout error in the browser. This number might need to be as low as 100\n   * if 15,000 markers are being managed, for example.\n   *\n   * @default `MarkerClusterer.BATCH_SIZE_IE`\n   */\n  batchSizeIE?: number;\n  /**\n   * The full URL of the root name of the group of image files to use for cluster icons.\n   * The complete file name is of the form `imagePath`n.`imageExtension`\n   * where n is the image file number (1, 2, etc.).\n   *\n   * @default `MarkerClusterer.IMAGE_PATH`\n   */\n  imagePath?: string;\n  /**\n   * The extension name for the cluster icon image files (e.g., `\"png\"` or\n   * `\"jpg\"`).\n   *\n   * @default `MarkerClusterer.IMAGE_EXTENSION`\n   */\n  imageExtension?: string;\n  /**\n   * An array of numbers containing the widths of the group of\n   * `imagePath`n.`imageExtension` image files.\n   * (The images are assumed to be square.)\n   *\n   * @default `MarkerClusterer.IMAGE_SIZES`\n   */\n  imageSizes?: number[];\n  /**\n   * A function to take the text attribute associated with the cluster and output a string to attach an\n   * ariaLabel to the cluster\n   */\n  ariaLabelFn?: AriaLabelFn;\n}\n\n/**\n * @ignore\n */\nconst getOption = <T, K extends keyof T>(\n  options: T,\n  prop: K,\n  def: T[K]\n): T[K] => {\n  if (options[prop] !== undefined) {\n    return options[prop];\n  } else {\n    return def;\n  }\n};\n\nexport class MarkerClusterer extends OverlayViewSafe {\n  /**\n   * The number of markers to process in one batch.\n   */\n  static BATCH_SIZE = 2000;\n\n  /**\n   * The number of markers to process in one batch (IE only).\n   */\n  static BATCH_SIZE_IE = 500;\n\n  /**\n   * The default root name for the marker cluster images.\n   */\n  static IMAGE_PATH = \"../images/m\";\n\n  /**\n   * The default extension name for the marker cluster images.\n   */\n  static IMAGE_EXTENSION = \"png\";\n\n  /**\n   * The default array of sizes for the marker cluster images.\n   */\n  static IMAGE_SIZES: number[] = [53, 56, 66, 78, 90];\n\n  private markers_: ClusterAugmentedMarker[] = [];\n  private clusters_: Cluster[] = [];\n  private listeners_: google.maps.MapsEventListener[] = [];\n\n  private activeMap_: google.maps.Map = null;\n  private ready_ = false;\n\n  public ariaLabelFn = this.options.ariaLabelFn || ((): string => \"\");\n\n  private zIndex_ = this.options.zIndex || google.maps.Marker.MAX_ZINDEX + 1;\n  private gridSize_ = this.options.gridSize || 60;\n  private minClusterSize_ = this.options.minimumClusterSize || 2;\n  private maxZoom_ = this.options.maxZoom || null;\n  private styles_: ClusterIconStyle[] = this.options.styles || [];\n  private title_ = this.options.title || \"\";\n\n  private zoomOnClick_ = getOption(this.options, \"zoomOnClick\", true);\n  private averageCenter_ = getOption(this.options, \"averageCenter\", false);\n\n  private ignoreHidden_ = getOption(this.options, \"ignoreHidden\", false);\n  private enableRetinaIcons_ = getOption(\n    this.options,\n    \"enableRetinaIcons\",\n    false\n  );\n\n  private imagePath_ = this.options.imagePath || MarkerClusterer.IMAGE_PATH;\n  private imageExtension_ =\n    this.options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;\n  private imageSizes_ = this.options.imageSizes || MarkerClusterer.IMAGE_SIZES;\n  private calculator_ = this.options.calculator || MarkerClusterer.CALCULATOR;\n  private batchSize_ = this.options.batchSize || MarkerClusterer.BATCH_SIZE;\n  private batchSizeIE_ =\n    this.options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;\n  private clusterClass_ = this.options.clusterClass || \"cluster\";\n\n  private prevZoom_: number;\n  private timerRefStatic: number;\n\n  /**\n   * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.\n   * @param map The Google map to attach to.\n   * @param markers The markers to be added to the cluster.\n   * @param options The optional parameters.\n   */\n  constructor(\n    map: google.maps.Map,\n    markers: google.maps.Marker[] = [],\n    private options: MarkerClustererOptions = {}\n  ) {\n    super();\n\n    if (navigator.userAgent.toLowerCase().indexOf(\"msie\") !== -1) {\n      // Try to avoid IE timeout when processing a huge number of markers:\n      this.batchSize_ = this.batchSizeIE_;\n    }\n\n    this.setupStyles_();\n\n    this.addMarkers(markers, true);\n    this.setMap(map); // Note: this causes onAdd to be called\n  }\n\n  /**\n   * Implementation of the onAdd interface method.\n   * @ignore\n   */\n  onAdd(): void {\n    this.activeMap_ = this.getMap() as google.maps.Map;\n    this.ready_ = true;\n\n    this.repaint();\n\n    this.prevZoom_ = this.getMap().getZoom();\n\n    // Add the map event listeners\n    this.listeners_ = [\n      google.maps.event.addListener(this.getMap(), \"zoom_changed\", () => {\n        const map: google.maps.Map & {\n          minZoom: number;\n          maxZoom: number;\n          mapTypes: { [type: string]: google.maps.MapType };\n        } = this.getMap() as any; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n        // Fix for bug #407\n        // Determines map type and prevents illegal zoom levels\n        const minZoom = map.minZoom || 0;\n        const maxZoom = Math.min(\n          map.maxZoom || 100,\n          map.mapTypes[map.getMapTypeId()].maxZoom\n        );\n        const zoom = Math.min(\n          Math.max(this.getMap().getZoom(), minZoom),\n          maxZoom\n        );\n\n        if (this.prevZoom_ != zoom) {\n          this.prevZoom_ = zoom;\n          this.resetViewport_(false);\n        }\n      }),\n      google.maps.event.addListener(this.getMap(), \"idle\", () => {\n        this.redraw_();\n      })\n    ];\n  }\n\n  /**\n   * Implementation of the onRemove interface method.\n   * Removes map event listeners and all cluster icons from the DOM.\n   * All managed markers are also put back on the map.\n   * @ignore\n   */\n  onRemove(): void {\n    // Put all the managed markers back on the map:\n    for (let i = 0; i < this.markers_.length; i++) {\n      if (this.markers_[i].getMap() !== this.activeMap_) {\n        this.markers_[i].setMap(this.activeMap_);\n      }\n    }\n\n    // Remove all clusters:\n    for (let i = 0; i < this.clusters_.length; i++) {\n      this.clusters_[i].remove();\n    }\n    this.clusters_ = [];\n\n    // Remove map event listeners:\n    for (let i = 0; i < this.listeners_.length; i++) {\n      google.maps.event.removeListener(this.listeners_[i]);\n    }\n    this.listeners_ = [];\n\n    this.activeMap_ = null;\n    this.ready_ = false;\n  }\n\n  /**\n   * Implementation of the draw interface method.\n   * @ignore\n   */\n  draw(): void {}\n\n  /**\n   * Sets up the styles object.\n   */\n  private setupStyles_(): void {\n    if (this.styles_.length > 0) {\n      return;\n    }\n\n    for (let i = 0; i < this.imageSizes_.length; i++) {\n      const size = this.imageSizes_[i];\n      this.styles_.push(\n        MarkerClusterer.withDefaultStyle({\n          url: this.imagePath_ + (i + 1) + \".\" + this.imageExtension_,\n          height: size,\n          width: size\n        })\n      );\n    }\n  }\n\n  /**\n   *  Fits the map to the bounds of the markers managed by the clusterer.\n   */\n  fitMapToMarkers(padding: number | google.maps.Padding): void {\n    const markers = this.getMarkers();\n    const bounds = new google.maps.LatLngBounds();\n    for (let i = 0; i < markers.length; i++) {\n      // March 3, 2018: Bug fix -- honor the ignoreHidden property\n      if (markers[i].getVisible() || !this.getIgnoreHidden()) {\n        bounds.extend(markers[i].getPosition());\n      }\n    }\n\n    (this.getMap() as google.maps.Map).fitBounds(bounds, padding);\n  }\n\n  /**\n   * Returns the value of the `gridSize` property.\n   *\n   * @return The grid size.\n   */\n  getGridSize(): number {\n    return this.gridSize_;\n  }\n\n  /**\n   * Sets the value of the `gridSize` property.\n   *\n   * @param gridSize The grid size.\n   */\n  setGridSize(gridSize: number): void {\n    this.gridSize_ = gridSize;\n  }\n\n  /**\n   * Returns the value of the `minimumClusterSize` property.\n   *\n   * @return The minimum cluster size.\n   */\n  getMinimumClusterSize(): number {\n    return this.minClusterSize_;\n  }\n\n  /**\n   * Sets the value of the `minimumClusterSize` property.\n   *\n   * @param minimumClusterSize The minimum cluster size.\n   */\n  setMinimumClusterSize(minimumClusterSize: number): void {\n    this.minClusterSize_ = minimumClusterSize;\n  }\n\n  /**\n   *  Returns the value of the `maxZoom` property.\n   *\n   *  @return The maximum zoom level.\n   */\n  getMaxZoom(): number {\n    return this.maxZoom_;\n  }\n\n  /**\n   *  Sets the value of the `maxZoom` property.\n   *\n   *  @param maxZoom The maximum zoom level.\n   */\n  setMaxZoom(maxZoom: number): void {\n    this.maxZoom_ = maxZoom;\n  }\n\n  getZIndex(): number {\n    return this.zIndex_;\n  }\n\n  setZIndex(zIndex: number): void {\n    this.zIndex_ = zIndex;\n  }\n\n  /**\n   *  Returns the value of the `styles` property.\n   *\n   *  @return The array of styles defining the cluster markers to be used.\n   */\n  getStyles(): ClusterIconStyle[] {\n    return this.styles_;\n  }\n\n  /**\n   *  Sets the value of the `styles` property.\n   *\n   *  @param styles The array of styles to use.\n   */\n  setStyles(styles: ClusterIconStyle[]): void {\n    this.styles_ = styles;\n  }\n\n  /**\n   * Returns the value of the `title` property.\n   *\n   * @return The content of the title text.\n   */\n  getTitle(): string {\n    return this.title_;\n  }\n\n  /**\n   *  Sets the value of the `title` property.\n   *\n   *  @param title The value of the title property.\n   */\n  setTitle(title: string): void {\n    this.title_ = title;\n  }\n\n  /**\n   * Returns the value of the `zoomOnClick` property.\n   *\n   * @return True if zoomOnClick property is set.\n   */\n  getZoomOnClick(): boolean {\n    return this.zoomOnClick_;\n  }\n\n  /**\n   *  Sets the value of the `zoomOnClick` property.\n   *\n   *  @param zoomOnClick The value of the zoomOnClick property.\n   */\n  setZoomOnClick(zoomOnClick: boolean): void {\n    this.zoomOnClick_ = zoomOnClick;\n  }\n\n  /**\n   * Returns the value of the `averageCenter` property.\n   *\n   * @return True if averageCenter property is set.\n   */\n  getAverageCenter(): boolean {\n    return this.averageCenter_;\n  }\n\n  /**\n   *  Sets the value of the `averageCenter` property.\n   *\n   *  @param averageCenter The value of the averageCenter property.\n   */\n  setAverageCenter(averageCenter: boolean): void {\n    this.averageCenter_ = averageCenter;\n  }\n\n  /**\n   * Returns the value of the `ignoreHidden` property.\n   *\n   * @return True if ignoreHidden property is set.\n   */\n  getIgnoreHidden(): boolean {\n    return this.ignoreHidden_;\n  }\n\n  /**\n   *  Sets the value of the `ignoreHidden` property.\n   *\n   *  @param ignoreHidden The value of the ignoreHidden property.\n   */\n  setIgnoreHidden(ignoreHidden: boolean): void {\n    this.ignoreHidden_ = ignoreHidden;\n  }\n\n  /**\n   * Returns the value of the `enableRetinaIcons` property.\n   *\n   * @return True if enableRetinaIcons property is set.\n   */\n  getEnableRetinaIcons(): boolean {\n    return this.enableRetinaIcons_;\n  }\n\n  /**\n   *  Sets the value of the `enableRetinaIcons` property.\n   *\n   *  @param enableRetinaIcons The value of the enableRetinaIcons property.\n   */\n  setEnableRetinaIcons(enableRetinaIcons: boolean): void {\n    this.enableRetinaIcons_ = enableRetinaIcons;\n  }\n\n  /**\n   * Returns the value of the `imageExtension` property.\n   *\n   * @return The value of the imageExtension property.\n   */\n  getImageExtension(): string {\n    return this.imageExtension_;\n  }\n\n  /**\n   *  Sets the value of the `imageExtension` property.\n   *\n   *  @param imageExtension The value of the imageExtension property.\n   */\n  setImageExtension(imageExtension: string): void {\n    this.imageExtension_ = imageExtension;\n  }\n\n  /**\n   * Returns the value of the `imagePath` property.\n   *\n   * @return The value of the imagePath property.\n   */\n  getImagePath(): string {\n    return this.imagePath_;\n  }\n\n  /**\n   *  Sets the value of the `imagePath` property.\n   *\n   *  @param imagePath The value of the imagePath property.\n   */\n  setImagePath(imagePath: string): void {\n    this.imagePath_ = imagePath;\n  }\n\n  /**\n   * Returns the value of the `imageSizes` property.\n   *\n   * @return The value of the imageSizes property.\n   */\n  getImageSizes(): number[] {\n    return this.imageSizes_;\n  }\n\n  /**\n   *  Sets the value of the `imageSizes` property.\n   *\n   *  @param imageSizes The value of the imageSizes property.\n   */\n  setImageSizes(imageSizes: number[]): void {\n    this.imageSizes_ = imageSizes;\n  }\n\n  /**\n   * Returns the value of the `calculator` property.\n   *\n   * @return the value of the calculator property.\n   */\n  getCalculator(): Calculator {\n    return this.calculator_;\n  }\n\n  /**\n   * Sets the value of the `calculator` property.\n   *\n   * @param calculator The value of the calculator property.\n   */\n  setCalculator(calculator: Calculator): void {\n    this.calculator_ = calculator;\n  }\n\n  /**\n   * Returns the value of the `batchSizeIE` property.\n   *\n   * @return the value of the batchSizeIE property.\n   */\n  getBatchSizeIE(): number {\n    return this.batchSizeIE_;\n  }\n\n  /**\n   * Sets the value of the `batchSizeIE` property.\n   *\n   *  @param batchSizeIE The value of the batchSizeIE property.\n   */\n  setBatchSizeIE(batchSizeIE: number): void {\n    this.batchSizeIE_ = batchSizeIE;\n  }\n\n  /**\n   * Returns the value of the `clusterClass` property.\n   *\n   * @return the value of the clusterClass property.\n   */\n  getClusterClass(): string {\n    return this.clusterClass_;\n  }\n\n  /**\n   * Sets the value of the `clusterClass` property.\n   *\n   *  @param clusterClass The value of the clusterClass property.\n   */\n  setClusterClass(clusterClass: string): void {\n    this.clusterClass_ = clusterClass;\n  }\n\n  /**\n   *  Returns the array of markers managed by the clusterer.\n   *\n   *  @return The array of markers managed by the clusterer.\n   */\n  getMarkers(): google.maps.Marker[] {\n    return this.markers_;\n  }\n\n  /**\n   *  Returns the number of markers managed by the clusterer.\n   *\n   *  @return The number of markers.\n   */\n  getTotalMarkers(): number {\n    return this.markers_.length;\n  }\n\n  /**\n   * Returns the current array of clusters formed by the clusterer.\n   *\n   * @return The array of clusters formed by the clusterer.\n   */\n  getClusters(): Cluster[] {\n    return this.clusters_;\n  }\n\n  /**\n   * Returns the number of clusters formed by the clusterer.\n   *\n   * @return The number of clusters formed by the clusterer.\n   */\n  getTotalClusters(): number {\n    return this.clusters_.length;\n  }\n\n  /**\n   * Adds a marker to the clusterer. The clusters are redrawn unless\n   *  `nodraw` is set to `true`.\n   *\n   * @param marker The marker to add.\n   * @param nodraw Set to `true` to prevent redrawing.\n   */\n  addMarker(marker: google.maps.Marker, nodraw?: boolean): void {\n    this.pushMarkerTo_(marker);\n    if (!nodraw) {\n      this.redraw_();\n    }\n  }\n\n  /**\n   * Adds an array of markers to the clusterer. The clusters are redrawn unless\n   *  `nodraw` is set to `true`.\n   *\n   * @param markers The markers to add.\n   * @param nodraw Set to `true` to prevent redrawing.\n   */\n  addMarkers(markers: google.maps.Marker[], nodraw?: boolean): void {\n    for (const key in markers) {\n      if (Object.prototype.hasOwnProperty.call(markers, key)) {\n        this.pushMarkerTo_(markers[key]);\n      }\n    }\n    if (!nodraw) {\n      this.redraw_();\n    }\n  }\n\n  /**\n   * Pushes a marker to the clusterer.\n   *\n   * @param marker The marker to add.\n   */\n  private pushMarkerTo_(\n    marker: google.maps.Marker & { isAdded?: boolean }\n  ): void {\n    // If the marker is draggable add a listener so we can update the clusters on the dragend:\n    if (marker.getDraggable()) {\n      google.maps.event.addListener(marker, \"dragend\", () => {\n        if (this.ready_) {\n          marker.isAdded = false;\n          this.repaint();\n        }\n      });\n    }\n    marker.isAdded = false;\n    this.markers_.push(marker);\n  }\n\n  /**\n   * Removes a marker from the cluster.  The clusters are redrawn unless\n   *  `nodraw` is set to `true`. Returns `true` if the\n   *  marker was removed from the clusterer.\n   *\n   * @param marker The marker to remove.\n   * @param nodraw Set to `true` to prevent redrawing.\n   * @return True if the marker was removed from the clusterer.\n   */\n  removeMarker(marker: google.maps.Marker, nodraw?: boolean): boolean {\n    const removed = this.removeMarker_(marker);\n\n    if (!nodraw && removed) {\n      this.repaint();\n    }\n\n    return removed;\n  }\n\n  /**\n   * Removes an array of markers from the cluster. The clusters are redrawn unless\n   *  `nodraw` is set to `true`. Returns `true` if markers were removed from the clusterer.\n   *\n   * @param markers The markers to remove.\n   * @param nodraw Set to `true` to prevent redrawing.\n   * @return True if markers were removed from the clusterer.\n   */\n  removeMarkers(markers: google.maps.Marker[], nodraw?: boolean): boolean {\n    let removed = false;\n\n    for (let i = 0; i < markers.length; i++) {\n      const r = this.removeMarker_(markers[i]);\n      removed = removed || r;\n    }\n\n    if (!nodraw && removed) {\n      this.repaint();\n    }\n\n    return removed;\n  }\n\n  /**\n   * Removes a marker and returns true if removed, false if not.\n   *\n   * @param marker The marker to remove\n   * @return Whether the marker was removed or not\n   */\n  private removeMarker_(marker: google.maps.Marker): boolean {\n    let index = -1;\n    if (this.markers_.indexOf) {\n      index = this.markers_.indexOf(marker);\n    } else {\n      for (let i = 0; i < this.markers_.length; i++) {\n        if (marker === this.markers_[i]) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false;\n    }\n\n    marker.setMap(null);\n    this.markers_.splice(index, 1); // Remove the marker from the list of managed markers\n    return true;\n  }\n\n  /**\n   * Removes all clusters and markers from the map and also removes all markers\n   *  managed by the clusterer.\n   */\n  clearMarkers(): void {\n    this.resetViewport_(true);\n    this.markers_ = [];\n  }\n\n  /**\n   * Recalculates and redraws all the marker clusters from scratch.\n   *  Call this after changing any properties.\n   */\n  repaint(): void {\n    const oldClusters = this.clusters_.slice();\n    this.clusters_ = [];\n    this.resetViewport_(false);\n    this.redraw_();\n\n    // Remove the old clusters.\n    // Do it in a timeout to prevent blinking effect.\n    setTimeout(function() {\n      for (let i = 0; i < oldClusters.length; i++) {\n        oldClusters[i].remove();\n      }\n    }, 0);\n  }\n\n  /**\n   * Returns the current bounds extended by the grid size.\n   *\n   * @param bounds The bounds to extend.\n   * @return The extended bounds.\n   * @ignore\n   */\n  getExtendedBounds(\n    bounds: google.maps.LatLngBounds\n  ): google.maps.LatLngBounds {\n    const projection = this.getProjection();\n\n    // Turn the bounds into latlng.\n    const tr = new google.maps.LatLng(\n      bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng()\n    );\n    const bl = new google.maps.LatLng(\n      bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng()\n    );\n\n    // Convert the points to pixels and the extend out by the grid size.\n    const trPix = projection.fromLatLngToDivPixel(tr);\n    trPix.x += this.gridSize_;\n    trPix.y -= this.gridSize_;\n\n    const blPix = projection.fromLatLngToDivPixel(bl);\n    blPix.x -= this.gridSize_;\n    blPix.y += this.gridSize_;\n\n    // Convert the pixel points back to LatLng\n    const ne = projection.fromDivPixelToLatLng(trPix);\n    const sw = projection.fromDivPixelToLatLng(blPix);\n\n    // Extend the bounds to contain the new bounds.\n    bounds.extend(ne);\n    bounds.extend(sw);\n\n    return bounds;\n  }\n\n  /**\n   * Redraws all the clusters.\n   */\n  private redraw_(): void {\n    this.createClusters_(0);\n  }\n\n  /**\n   * Removes all clusters from the map. The markers are also removed from the map\n   *  if `hide` is set to `true`.\n   *\n   * @param hide Set to `true` to also remove the markers from the map.\n   */\n  private resetViewport_(hide?: boolean): void {\n    // Remove all the clusters\n    for (let i = 0; i < this.clusters_.length; i++) {\n      this.clusters_[i].remove();\n    }\n    this.clusters_ = [];\n\n    // Reset the markers to not be added and to be removed from the map.\n    for (let i = 0; i < this.markers_.length; i++) {\n      const marker = this.markers_[i];\n      marker.isAdded = false;\n      if (hide) {\n        marker.setMap(null);\n      }\n    }\n  }\n\n  /**\n   * Calculates the distance between two latlng locations in km.\n   *\n   * @param p1 The first lat lng point.\n   * @param p2 The second lat lng point.\n   * @return The distance between the two points in km.\n   * @link http://www.movable-type.co.uk/scripts/latlong.html\n   */\n  private distanceBetweenPoints_(\n    p1: google.maps.LatLng,\n    p2: google.maps.LatLng\n  ): number {\n    const R = 6371; // Radius of the Earth in km\n    const dLat = ((p2.lat() - p1.lat()) * Math.PI) / 180;\n    const dLon = ((p2.lng() - p1.lng()) * Math.PI) / 180;\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos((p1.lat() * Math.PI) / 180) *\n        Math.cos((p2.lat() * Math.PI) / 180) *\n        Math.sin(dLon / 2) *\n        Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  /**\n   * Determines if a marker is contained in a bounds.\n   *\n   * @param marker The marker to check.\n   * @param bounds The bounds to check against.\n   * @return True if the marker is in the bounds.\n   */\n  private isMarkerInBounds_(\n    marker: google.maps.Marker,\n    bounds: google.maps.LatLngBounds\n  ): boolean {\n    return bounds.contains(marker.getPosition());\n  }\n\n  /**\n   * Adds a marker to a cluster, or creates a new cluster.\n   *\n   * @param marker The marker to add.\n   */\n  private addToClosestCluster_(marker: google.maps.Marker): void {\n    let distance = 40000; // Some large number\n    let clusterToAddTo = null;\n    for (let i = 0; i < this.clusters_.length; i++) {\n      const cluster = this.clusters_[i];\n      const center = cluster.getCenter();\n      if (center) {\n        const d = this.distanceBetweenPoints_(center, marker.getPosition());\n        if (d < distance) {\n          distance = d;\n          clusterToAddTo = cluster;\n        }\n      }\n    }\n\n    if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n      clusterToAddTo.addMarker(marker);\n    } else {\n      const cluster = new Cluster(this);\n      cluster.addMarker(marker);\n      this.clusters_.push(cluster);\n    }\n  }\n\n  /**\n   * Creates the clusters. This is done in batches to avoid timeout errors\n   *  in some browsers when there is a huge number of markers.\n   *\n   * @param iFirst The index of the first marker in the batch of\n   *  markers to be added to clusters.\n   */\n  private createClusters_(iFirst: number): void {\n    if (!this.ready_) {\n      return;\n    }\n\n    // Cancel previous batch processing if we're working on the first batch:\n    if (iFirst === 0) {\n      google.maps.event.trigger(this, \"clusteringbegin\", this);\n\n      if (typeof this.timerRefStatic !== \"undefined\") {\n        clearTimeout(this.timerRefStatic);\n        delete this.timerRefStatic;\n      }\n    }\n\n    // Get our current map view bounds.\n    // Create a new bounds object so we don't affect the map.\n    //\n    // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:\n    let mapBounds: google.maps.LatLngBounds;\n\n    if (this.getMap().getZoom() > 3) {\n      mapBounds = new google.maps.LatLngBounds(\n        (this.getMap() as google.maps.Map).getBounds().getSouthWest(),\n        (this.getMap() as google.maps.Map).getBounds().getNorthEast()\n      );\n    } else {\n      mapBounds = new google.maps.LatLngBounds(\n        new google.maps.LatLng(85.02070771743472, -178.48388434375),\n        new google.maps.LatLng(-85.08136444384544, 178.00048865625)\n      );\n    }\n    const bounds = this.getExtendedBounds(mapBounds);\n\n    const iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);\n\n    for (let i = iFirst; i < iLast; i++) {\n      const marker = this.markers_[i];\n      if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n        if (\n          !this.ignoreHidden_ ||\n          (this.ignoreHidden_ && marker.getVisible())\n        ) {\n          this.addToClosestCluster_(marker);\n        }\n      }\n    }\n\n    if (iLast < this.markers_.length) {\n      this.timerRefStatic = window.setTimeout(() => {\n        this.createClusters_(iLast);\n      }, 0);\n    } else {\n      delete this.timerRefStatic;\n      google.maps.event.trigger(this, \"clusteringend\", this);\n\n      for (let i = 0; i < this.clusters_.length; i++) {\n        this.clusters_[i].updateIcon();\n      }\n    }\n  }\n\n  /**\n   * The default function for determining the label text and style\n   * for a cluster icon.\n   *\n   * @param markers The array of markers represented by the cluster.\n   * @param numStyles The number of marker styles available.\n   * @return The information resource for the cluster.\n   */\n  static CALCULATOR(\n    markers: google.maps.Marker[],\n    numStyles: number\n  ): ClusterIconInfo {\n    let index = 0;\n    const count: number = markers.length;\n\n    let dv = count;\n    while (dv !== 0) {\n      dv = Math.floor(dv / 10);\n      index++;\n    }\n\n    index = Math.min(index, numStyles);\n    return {\n      text: count.toString(),\n      index: index,\n      title: \"\"\n    };\n  }\n\n  /**\n   * Generates default styles augmented with user passed values.\n   * Useful when you want to override some default values but keep untouched\n   *\n   * @param overrides override default values\n   */\n  static withDefaultStyle(overrides: ClusterIconStyle): ClusterIconStyle {\n    return {\n      textColor: \"black\",\n      textSize: 11,\n      textDecoration: \"none\",\n      textLineHeight: overrides.height,\n      fontWeight: \"bold\",\n      fontStyle: \"normal\",\n      fontFamily: \"Arial,sans-serif\",\n      backgroundPosition: \"0 0\",\n      ...overrides\n    };\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MarkerClusterer } from \"./markerclusterer\";\n\nexport { ClusterIconInfo, ClusterIconStyle } from \"./cluster-icon\";\nexport { MarkerClustererOptions } from \"./markerclusterer\";\n\nexport default MarkerClusterer;\n"]},"metadata":{},"sourceType":"module"}